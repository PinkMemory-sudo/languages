Java容器主要有两大接口：Collection和Map



* 排序
* 各自的优缺点
* 各自的数据结构
* 存取原理
* java7和Java8中的区别
* 为什么会线程不安全？有什么解决办法
* hash的计算规则，怎么解决hash碰撞







**HashMap**

？

* HashMap的扩容机制，负载因子
* 默认初始化容量为什么是16
* 为什么容量总是2的幂



由数组和链表组成，1.8添加了红黑树，将时间复杂度降到了O(logn)

put时根据key的hash计算出一个index



Node

每个Node都保存了自身的hash,key,value及下一个Node



新节点插入链表时是怎么插的？

1.8之前是头插法，作者认为后插入的被查询的可能性大，1.8之后改成了尾插法



**扩容机制**

数组的容量是有限的，当达到一定数量时就会进行扩容。

1. 创建一个新的空数组，长度是原来的2倍
2. 遍历原来的数组，重新hash到新数组中(因为长度变化后，hash规则也随之发生了变化)



index = HashCode（Key） & （Length - 1）

**之所以用位与运算效果与取模一样，性能也提高了不少**

取模和与运算的关系：与n取模就是与(n-1)做与运算



**为什么变成了尾插法**

**使用尾插**，在扩容时会保持链表元素原本的顺序，就不会出现链表成环的问题了



**HashMap的初始容量为什么是16？**

怎么尽可能的得到一个均匀分布的hash呢？





**容量为什么建议是2的幂？**

`X % 2^n = X & (2^n – 1)`

只要保证长度是2的n次方就可以通过与

`x/8=X>>3`



**HashMap如何保证容量一定是2的幂的？**

我们指定的初始容量，HashMap会计算出来一个值作为初始容量

计算过程：





**扩容因子**

设置成0.75的好处是与容量相乘，得到的都是整数



**重写equals方法的时候需要重写hashCode方法呢？**

Ojbect类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的。

对于值对象，==比较的是两个对象的值。对于引用对象，==比较的是两个对象的地址。

通过key的HashCodo来计算出index，怎么才能找到key呢。

**equals**！所以如果我们对equals方法进行了重写，建议一定要对hashCode方法重写，以保证相同的对象返回相同的hash值，不同的对象返回不同的hash值。



**HashMap的线程安全问题**

存在线程不安全的场景时可以使用CorruentHashMap，HashTable的并发度太低。

HashTable直接在方法上加锁，currentHashMap就好很多了



**HashMap在JDK1.7中为什么会出现死循环？**

扩容时，需要将旧表中的数据迁移到新表中，使用的是头插法，会使链表的顺序反转(这是出现死循环的关键点)



**HashMap为什么线程不安全？**

jdk1.7在多线程不断进行put的情况下HashMap容器出现死循环。



**Hashmap中的链表大小超过八个时会自动转化为红黑树，当删除小于六时重新变为链表?**



**HashTable**

HashTable不允许null，在put时就会失败



# ConcurrentHashMap



**分段锁**

支持 CurrencyLevel (Segment 数组数量)的线程并发