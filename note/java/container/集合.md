* Collection接口
* LIst接口
* 集合与数组的相互转换
* 各个容器增删改查的时间复杂度
* 有序性
* null



如何选取合适的容器？

* 是否能满足需求
* 是否更高效



Collection接口是集合框架的顶级接口，规定了集合的增删改查，批量的添加和删除，判断等方法；

* 返回的迭代器不保证有序性

有序指的是插入的顺序和遍历出来的数序是否一致

集合转数组：

```java
<T> T[] toArray(T[] a);
```

如果提供的array合适就返回到数组，不合适就用指定的类型重新创建一个数组

如果该集合是有序的，则返回的数组也是有序的

`removeIf` 去除符合条件的元素

`retainAll` 去除不在指定集合中的所有元素

`containsAll` 是否包含指定集合中的所有元素



# List

* 初始容量
* 扩容
* 数据结构
* 性能
* 安全性

有序的，可重复



主要方法：

`indexOf`

`lastIndexOf`

`listIterator`

`listIterator(int index)`

`subList`



## **ArrayList**

`clone`

`sort`

`trimToSize`



初始容量为10，初始其实是空数组 当添加第一个元素的时候数组容量才变成10(指定容量时直接创建一个指定大小的数组)。

底层是数组。RandomAccess 是一个标志接口，表明实现这个这个接口的 List 集合是支持快速随机访问。

线程不安全



**扩容机制**

add方法里，首先判断是否需要扩容，需要扩容是会调用grow()方法， 然后使用数组拷 贝的方法，把以前存放的数据转移到新的数组对象中 。

```
新容量=旧容量+(就容量>>2)
```







## LinkedList



**数据结构**：双向链表



**ArrayList与LinkedList的对比**

* 数据结构不同：ArrayList使用的是数组，可以随机访问。LinkedList使用的是双向链表

* ArrayList内存使用效率更高，ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间



## Vector

已经弃用了，因为它有太多的synchronized，保证线程安全但是性能太低

ArrayList扩容是1.5，Vector是2



## Queue



## Stack





# Set



无序，不重复

数值放在 map 中的 key 上，value 上放了个 PRESENT，是一个静态的 Object，相当于 place holder，每个 key 都指向这个 object。



## **HashSet**

采用 Hashmap 的 key 来储存元素，主要特点是无序的，基本操作都是 O(1) 的时间复杂度，很快。



## **LinkedHashSet**

这个是一个 HashSet + LinkedList 的结构，特点就是既拥有了 O(1) 的时间复杂度，又能够保留插入的顺序。



## **TreeSet**

采用红黑树结构，特点是可以有序，可以用自然排序或者自定义比较器来排序；缺点就是查询速度没有 HashSet 快。



























































