强弱软虚

# JVM



## JVM内存划分



**直接内存**

非运行时数据区的一部分，其他的都是运行时数据区。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部 分内存也被频繁地使用



### 线程共有的

**堆**

JVM中堆是最大的一块内存空间，所有线程共享的一块区域，在虚拟机启动的时候创建。堆还可以细分，详情看GC部分。

用来存放new出来的数据。几乎所有的对象都保存在堆中，随着JIT编译期的发展与逃逸分析技术逐渐 成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐 变得不那么“绝对”了。

从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被 返回或者未被外面使用(也就是未逃逸出去)，那么对象可以直接在栈上分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC** 堆

Jdk1.8前，堆被分为新生代，老年代，永久代

JDK 8 版本之后方法区(HotSpot 的永久代)被彻底移除了(JDK1.7 就已经开始了)，取而代 之是元空间，元空间使用的是直接内存

**方法区**

方法区用来存储已被虚拟机加载的**类信息**，常量，静态变量等。方法区也称为永久代。常量池是方法区的一部分

jdk1.8取消了方法区，用元空间代替。



### 线程私有的

**虚拟机栈**

用来描述方法执行的内存模型。每一次函数调用都会有一个 对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

存放着一个个栈帧，每个栈帧中保存着局部变量表，操作数栈，动态链接，方法出口等信息。

局部变量表存放着编译期可知的各种数据类和对象的引用

Java虚拟机栈可能会出现两种错误：StackOverFlowError 和 OutOfMemoryError

***StackOverFlowError*** : 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈 的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

***OutOfMemoryError*** : 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多 内存的话。就会抛出 OutOfMemoryError 错误。

**本地方法栈**

与虚拟机栈相似，但是本地方法栈执行的是native方法。在hotspot虚拟机中本地方法栈和Java虚拟机栈合而为一。

**程序计数器**

程序计数器记录着当前线程所执行的字节码的行号指示器，线程切换后根据程序计数器能恢复到正确的执行位置。





# GC



## **内存的分配和回收**

Java 自动内存管理最核心的功能是 堆 内存中对象的分配与回收。

由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为:新 生代和老年代:再细致一点有:Eden 空间、From Survivor、To Survivor 空间等。

**新生代**

分为Eden和Survivor，Survivor又分为from和to

大部分情况，对象都会首先在 Eden 区，当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.。在一次新生代垃圾回收后，如果对象还存活，则 会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区->Survivor 区后对象的初始年龄变为 1)， 当它的年龄增加到一定程度(默认为 15 岁)，就会被晋升到老年代中。对象晋升到老年代的年 龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。

经过一次GC后，经过这次 GC 后，Eden 区和"From"区已经被清空。"From"和"To"会交换他们的⻆ 色，也就是新的"To"就是上次 GC 前的“From”，新的"From"就是上次 GC 前的"To"



**如何判断对象是否应该被回收**

1. 引用技术法

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1;当引用失效，计数器就

减1;任何时候计数器为0的对象就是不可能再被使用的。

2. 可达性分析

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下 搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证 明此对象是不可用的。



## 垃圾收集算法



**标记清除法**

标记处要清除的所有对象，然后将所有的标记对象清除。

弊端：造成了地址空间的不连续，造成内存碎片。



**复制算法**

将内存分成两部分，一部分标记清除后，将剩下的对象移动到另一部分。

弊端：可用内存减少了一半



**标记整理**

再标记完之后，不是直接清理，而是将存活下来的对象先移动到另一端，然后再清理，这样就不需要分成两半了。

弊端：提高了空间利用率，但是移动增加了开销。



**分代收集算法**

根据对象所处生命周期划分为不同的几个空间，一般分为新生代老年代和永久代。

目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。

而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。



## 垃圾回收器



**Serial**

采用单线程进行垃圾回收，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程，直到它收集结束。

新生代采用赋值算法，老年代采用标记整理算法。

Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。



**ParNew**

就是Serial的多线程版本，它是许多运行在 Server 模式下的虚拟机的首要选择。