## JMM Java内存模型

[参考](https://zhuanlan.zhihu.com/p/29881777)



**什么是JMM，为什么要用JMM**

JMM是JVM的一套Java内存模型的规范，并不是真正存在的，是为了方便学习理解进行的抽象， 屏蔽掉各种硬件和操作系统的内存访问差异 。



## 硬件的内存



Java变量存储到了主内存，读取的话可能读到了缓存或者寄存器中。共享变量读取到不同处理器的寄存器上，产生可见性问题。

![1638115983908](E:\note\languages\note\img\1638115983908.png)

CPU执行速度很快，而内存到CPU读写数据相对来说比较慢，就出现了CPU高速缓存。运行时先将需要的数据从内存复制一份到告诉缓冲中，然后再写入寄存器。CPU直接从寄存器中读取数据，运行完之后再将高速缓冲中的数据刷入寄存器。

单线程运行时没什么问题，但是在多线程的运行中，一个线程复制到告诉缓冲区中后进行了修改，在还没有刷回内存时另一个线程有将内存中的数据刷入告诉缓冲区进行计算，这时已经不一致了，读取的实际是旧的。

解决缓存不一致问题一个做法是加锁，只能有一个线程对变量进行操作，刷回内存后才能被其他线程操作。锁住的是变量所在的内存地址，其他线程读取不了。这种做法导致了效率降低，有可能其他线程只是读取，并未要进行修改。这时就出现了缓存一致性协议：当CPU在曹硕共享变量时，会发出信号使该变量的缓存都失效，重新读取该变量



每个线程都有自己的栈空间，里面存放着方法和局部变量，都共享堆空间中的对象。而对于硬件来讲，没有什么堆和栈空间，所有东西都存在主内存，一些数据可能会存在Cache或Register中。CPU在读取变量时需要从主内存读到Cache，Cache再读进寄存器，一个CPU不能访问另一个CPU的寄存器，所以它们同时读取一个数据时，一个CPU更改另一个CPU却也在之前的数据上进行修改，看不见另一个CPU的修改，造成不可见性。

一个CPU的告诉缓冲器可以通过缓存一致性协议读取另一个缓存的数据更新到自己的缓存，这样保证可见性，为了保证可见性，必须将操作结果刷新到Cache中。



我们将这个模型抽象化，用来屏蔽掉各种硬件和操作系统的内存访问差异，帮助我们理解一个线程如何以及合适可以看到其他线程堆共享变量的修改结果，如何同步的访问共享变量。

![1638677940040](C:\Users\11942\AppData\Roaming\Typora\typora-user-images\1638677940040.png)

* 共享变量存入主内存中
* 每个线程都有一个私有的本地内存(工作内存)，抽象的概念，并不是真正存在的。(包含了Cache，Register等)，本地内存中存储这共享变量的副本，**线程不直接操作共享变量，而是在副本上进行操作**。各自的副本是独有的,其他线程不可见。



我们通过JMM来学习了解Java多线程的原子性，可见性和有序性等问题。



**原子性**

每个线程都有自己的本地内存，都可以将主内存中的变量复制到自己的工作内存，当线程A对变量进行修改时但还没有完成时，可能另一个线程B也进行了修改，这样看以来线程A的修改没有同时完成(原子性应该是要么执行要么都不执行，而现在线程A只执行了一部分)并不是原子性的。

Java有两种方式来实现原子性：使用锁和利用处理器的CAS指令。锁具有排他性，同一时刻只能被一个线程访问，CAS是从硬件方便实现的。



**可见性**

线程操作都是再本地内存中操作变量，所以一个线程修改了本地内存的变量，另一个线程并不能立马知道。



**有序性**

 为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化 。JMM并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。



**指令重排序**

处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序(单线程)最终执行结果和代码顺序执行的结果是一致的。对单线程而言：**貌似串行语义**。并不能保证多线程执行的结果。



**存储子系统重排序**

* LoadLoad重排序，一个处理器执行两个load操作L1,L2，另一个线程感知到的可能是L2,L1
* StoreStore重排序，一样的内存感知顺序反了
* LoadStore
* StoreLoad


