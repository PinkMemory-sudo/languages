

# 多线程



**进程和线程的区别**

* 进程是资源分配(内存，文件等)的最小单位，线程是CPU调度的最小单位。

* 一个进程可以有多个线程，共享进程的资源。所以线程执行时一般都要进行同步和互斥。
* 线程切换消耗的资源要比进程小得多，线程也被成为轻量级进程



**并发和并行的区别**

并发是一段时间内执行多个任务

并行是同一时间内执行多个任务



**为什么要使用多线程**

* 线程共享进程的资源，切换的开销要比进程小
* 一个线程在不使用CPU的情况下可以让别的线程先用，提高效率，减少执行的时间，提高并发量



**创建线程的方式**



 **实现 Runnable 接⼝和 Callable 接⼝的区别** 

* Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以。
* Runnable执行run方法，Callable执行call方法 



**执⾏ execute()⽅法和 submit()⽅法的区别是什么呢？**

* execute() ⽅法⽤于提交不需要返回值的任务
* submit() ⽅法⽤于提交需要返回值的任务， 线程池会返回⼀个 Future 类型的对象 。





**什么是守护线程**



**产生死锁的四个条件**

互斥条件：改资源任一时刻只能有一个线程占用

请求与保持条件：一个进程因请求资源而阻塞时，不释放自己一获得的资源

不剥夺条件：线程已经获得的资源不可剥夺，只有自己使用完毕后才释放资源

循环等待条件：若干进程间形成一种头围相连的循环等待条件



**如何避免死锁**

破坏行程死锁的四个条件中的任意一条就可以：请求资源时一次请求全部的资源，没有得到时把自己已有的资源释放掉。

互斥条件：无法破坏，因为我们使用锁的目的就是让他互斥

请求与保持条件：一次申请全部资源，这样就不会因某个资源被其他线程占用而阻塞

不可剥夺条件：如果没有申请到其他线程占用的资源时，把自己占用的那部分释放掉

循环等待条件：





***线程的状态***

| 状态          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 新建状态                                                     |
| RUNNABLE      | 可运行状态，包含READY和RUNNING                               |
| BLOCKED       | 阻塞状态，线程发起阻塞的I/O操作或者申请其他线程占用的资源时。阻塞状态不会占用CPU |
| WAITING       | 等待状态，线程执行了wait或者join状态，执行notify或者加入的线程执行完后进入RUNNABLE |
| TIMED_WAITING | 与WAITING状态类似，但是指定的有时间，超时自动转RUNNABLE      |
| TERMINATED    | 线程运行完之后                                               |



***线程的生命周期***

| 声明周期 | 描述                      |
| -------- | ------------------------- |
| 新建     | 刚被创建                  |
| 就绪     | 调用start()后             |
| 运行     | 获得CPU执行权后           |
| 阻塞     | 阻塞和wait状态            |
| 死亡     | 执行完run方法或者异常退出 |



**sleep方法和wait方法的异同**

* 都会是线程进入阻塞状态，sleep不会释放锁，wait会释放锁。
* wait使用前提是先获得锁，通过锁调用wait方法

* sleep到时间后继续执行wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或 者 notinotify动苏醒。



**run方法和start方法的区别**

调用 start() 方法，会启动一个线程并使线程进入了就 绪状态，当分配到时间片后就可以开始运行了。

直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它



**FutureTask 对象** 



**Synchronized和Lock区别**

sunchronized发生异常会释放锁 



？

* 锁分离
* 线程的dump文件
* 线程池，最大线程数过大的后果





## 线程池



**线程池的优点，为什么要使用线程池**



**线程池原理分析**



**线程池的五种状态**



**线程池的参数**

| 参数                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| corePoolSize             | 线程池要保持的线程的数量                                     |
| maximumPoolSize          | 线程池中最多可以保存的线程数                                 |
| keepAliveTime            | 大于核心线程数时，如果执行时间内没有分配到任务就会清掉       |
| TimeUnit                 | keepAliveTime的单位                                          |
| BlockingQueue            | 在线程数达到最大时，就会存放在队列中(runnable通过execute提交的) |
| ThreadFactory            | 线程池用它来创建线程                                         |
| RejectedExecutionHandler | 线程数已经达到最大，并且队列也满了，对新提交的任务怎么拒绝   |

结合线程数先变大再减少的场景去记忆



**线程池的拒绝策略**

| 拒绝策略             | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| AbortPolicy          | 抛弃任务,直接抛出 RejectedExecutionException 异常阻止系统正常运行 |
| DiscardPolicy        | 直接抛弃任务，不抛出异常                                     |
| DiscardOledestPolicy | 丢弃掉最先入队的，重新尝试添加到队列中                       |
| CallerRunsPolicy     | 调用者自己去执行任务                                         |



**最大线程数设置过大会有什么后果**

* 线程时需要内存空间的，创建的线程过多就会占用过大的内存空间
* 线程上下文切换需要消耗时间，线程数太多而进行频繁切换也会浪费时间
* netty的建议是设置为2倍的cpu核心数。 



**使用wait和notify写一个生产者消费者代码**



**写一个线程安全的单例模式**



**进行对线程开发时，你有哪些最佳实践**

* 给线程命名，有助于调试
* 最小化同步的范围
* 使用更高层次的开发工具BlockQueue等而不是wait和notify
* 优先使用并发集合而不是同步
* 尽量把阻塞型的IO密集任务，转成CPU密集任务，这样你只需要少量线程也可以获得很高的吞吐量。这就是为何select、poll 、epoll、nginx可以用很少的线程可以获得极大吞吐量的原因。 



**线程同步的方法**

* Synchronized
* Lock
* volatile



## **Java内存模型**



 **ThreadLocal 了解么** 

 每⼀个线程都有自己的专属本地变量。

 ThrealLocal 类中可以通过 Thread.currentThread() 获取到当前线程对象后，直接通过 getMap(Thread t) 可以访问到该线程的 ThreadLocalMap 对象。 



 **ThreadLocal 原理** 

 最终的变量是放在了当前线程的 ThreadLocalMap 中 

当前对象调用set方法，实际是将值存在了ThreadLocalMap中，key是当前的Thread对象。



 **ThreadLocal 内存泄露问题了**

ThreadLocal.ThreadLocalMap.Entry中的key是弱引用的，也即是当某个ThreadLocal对象不存在强引用时，就会被GC回收，但是value是基于强引用的，所以当key被回收，但是value还存在其他强引用时，就会出现内存的泄露情况，在最新的ThreadLocal中已经做出了修改，即在调用set、get、remove方法时，会清除key为null的Entry，但是如果不调用这些方法，仍然还是会出现内存泄漏 ：），所以要养成用完ThreadLocal对象之后及时remove的习惯。





## Synchronized



**对于 synchronized 关键字的了解** 

synchronized关键字用来解决线程间的同步问题，synchronized修饰的方法和代码块在同一时间只能被一个线程执行。

synchronized关键字可以用来修饰实例方法，静态方法和代码块。修饰实例方法时，使用的锁对象时this，修饰静态方法时，使用的时当前类的Class对象，修饰代码块时自己指定锁对象。

 尽量不要使⽤ synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能， 两个String的值一致时指向的地址是一致的，其实两个线程锁的是同一个对象。



**Synchronized实现的底层原理**

 monitorenter 和 monitorexit 指令 

 ACC_SYNCHRONIZED 标 





**Synchronized锁升级的过程**

偏向锁：不释放

轻量级锁:CAS,自旋一段时间

重量级锁：完全阻塞

 因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映 射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成， 





## volatile



**创建volatile数组**

只保证了引用的可见性



**volatile能使一个非原子操作变成一个原子操作吗**



volatile提供了什么保证

* 可见性
* 一部分有序性



容器的Concurent

notify，线程通信

锁

wait，join，yeid，notify

Volatile、CAS

volatile 变量和 atomic 变量有什么不同

线程间通信，wait 和 notify 的理解和使用?

定时线程的使用?

什么是竞争条件

如何停止一个线程



volatile 的理解

实现多线程有几种方式

ReentrantLock

守护线程是什么？它和非守护线程的区别

线程阻塞有哪些原因

synchronized 和 Lock 的区别

ThreadLocal 是什么？有什么作用

什么是线程局部变量

FutureTask

什么是自旋

怎么唤醒一个阻塞的线程

使用 volatile 关键字的场景

线程池的工作原理，几个重要参数

线程池的类型

线程池的阻塞队列有哪些

线程池的拒绝策略都有哪些



**并发与并行**

并行就是一个时间点做多件事

并发就是一个时间段内来回切换做多件事



**为什么要使用多线程**

线程的切换成本远小于进程，多核 CPU 时代意味着多个线程可以同时运行，这减少 了线程上下文切换的开销。

为了提高CPU的利用率，减少程序运行时间。



**什么是上下文切换**

多线程通常是线程数大于CPU数，一个CPU来回切换来执行多个线程。当一个线程执行完CPU时间段切换到另一个线程前，会先将自己的当前状态先保存起来，等再次切换回这个任务时在把状态加载出来接着执行。

上下文切换通常是计算密集型的，也就是他要占用相当比例的处理器时间。Linux 相比与其他操作系统(包括其他类 Unix 系统)有很多的优点，其中有一项就是，其上下文 切换和模式切换的时间消耗非常少。



**多线程可能带来什么问题**

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如:内存泄漏、上下文切换、死锁 。



**线程的基本状态**

线程有流中状态

| 状态     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| new      | 新建 线程对象创建后进入新建状态                              |
| runnable | 就绪 线程的start()被调用后进入就绪态，等待CPU调度            |
| running  | 运行 获得CPU执行权后                                         |
| blocked  | 阻塞 因某种原因放弃了CPU的执行权进入阻塞态(等待阻塞，同步阻塞，其他阻塞)，随后会再次进入就绪态，等待获得CPU执行权 |
| dead     | 死亡 线程执行完后者引异常退出了run方法                       |

等待阻塞：

同步阻塞

其他阻塞











**synchronized**

synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。解决多个线程之间访问资源的同步性。



**为什么Java 早期版本中， synchronized 属于 重量级锁，效率低下**

因为监视器锁(monitor)是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映 射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而 操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比􏰀 ⻓的时间，时间成本相对􏰀高



**JDK1.6后synchronized的优化**

JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。



**怎么使用 synchronized 关键字**

**修饰实例方法**：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁

**修饰静态方法**：也就是给当前类加锁，会作用于类的所有对象实例。进入同步代码前要获得 当 前 class 的锁。

如果一个线程 A 调用一个实例对象的 非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法， 是允许的，不会发生互斥现象，因为访问静态 **synchronized** 方法占用的锁是当前类的锁，而访 问非静态 **synchronized** 方法占用的锁是当前实例对象锁。

**修饰代码块**：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进入同步代码 库前要获得给定对象的锁。 synchronized(􏰄.class) 表示进入同步代码前要获得 当前 **class** 的锁

总结：给Class加锁和给对象加锁



**双重校验实现单例对象**





 **构造方法可以使用 synchronized 关键字修饰么**

不能。

构造方法本身就属于线程安全的。



**synchronized 关键字的底层原理**



## JUC



**原子类**



**AQS**

**对于 AQS 原理的理解**

AQS 核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线
程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞
等待以及被唤醒时锁分配的机制，这个机制 AQS 是⽤ CLH 队列锁实现的，即将暂时获取不到锁
的线程加⼊到队列中。



**AQS 对资源的共享⽅式**

独占，共享guid



**⽤过 CountDownLatch 么？什么场景下⽤的**  