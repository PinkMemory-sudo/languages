* 原子性

* 可见性

* 重入锁
* 锁对象
* 死锁
* 公平锁与非公平锁



原子性：

在操作数据前，先加上锁，完成后再释放锁



重入锁

重入锁使得同一个线程可以对同一把锁，在不释放的前提下，反复加锁，而不会导致线程卡死，唯一需要保证的就是lock和unlock的次数相同



# Lock





**ReentrantLock**



`void lock()`

获得锁，setting the lock hold count to one，别的线程已经获得锁时就一直等待



`boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException`

尝试获取锁，等待timeout时间。同时，可以响应中断。

* 不用无限等待，避免形成死锁。如果一段时间等不到锁，可以直接放弃，同时释放自己已经得到的资源。这样，就可以在很大程度上，避免死锁的产生。
* 等待锁的过程中可以响应中断，如果此时，程序正好收到关机信号，中断就会触发，进入中断异常后，线程就可以做一些清理工作，从而防止在终止程序时出现数据写坏，数据丢失等悲催的情况



`boolean tryLock()`

这个不带任何参数的tryLock()不会进行任何等待，如果能够获得锁，直接返回true，如果获取失败，就返回false，特别适合在应用层自己对锁进行管理，在应用层进行自旋等待。



`unlock`



释放锁



**可重入锁实现原理**

就是基于一个状态变量state，当这个state==0时，表示锁是空闲的，大于零表示锁已经被占用， 它的数值表示当前线程重复占用这个锁的次数。

对state进行CAS操作，如果成功就占用锁，如果发现锁就是当前线程占用的，则更新state，表示重复占用的次数



**CAS**



**公平锁与非公平锁**

可重入锁默认是非公平锁，即谁先拿到锁是随机的，如果想先到咸的，就需要在创建锁的时候执行为公平锁

`ReentrantLock fairLock = new ReentrantLock(true);`



## **Condition**



重入锁的伴生对象Condition提供了await()和singal()的功能，可以用于线程间消息通信





* 竞争与协作
* 互斥与同步



线程是调度的基本单位，进程则是资源分配的基本单位。所以线程之间可以共享进程的资源，但每个线程都有自己独立的栈空间。



线程的同步















**锁的分类：**

公平/非公平

可重入/不可重入

独享/共享

互斥/读写

乐观/悲观

偏向/重量/轻量

自旋锁



**公平锁**

公平锁是指多个线程按照申请锁的顺序来获取锁

**非公平锁**

非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。

对于`Java ReentrantLock`而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。

对于`Synchronized`而言，也是一种非公平锁。由于其并不像`ReentrantLock`是通过`AQS`的来实现线程调度，所以并没有任何办法使其变成公平锁。

**可重入锁**

广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。`ReentrantLock`和`synchronized`都是可重入锁

比如

```java
synchronized void setA() throws Exception{
   Thread.sleep(1000);
   setB();
}
synchronized void setB() throws Exception{
   Thread.sleep(1000);
}
```



**独享锁**：该锁每一次只能被一个线程所持有。

**共享锁**：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。



## 锁的状态

* 无锁状态
* 偏向锁状态
* 轻量级锁状态
* 重量级锁状态

四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。

**这四种状态都不是Java语言中的锁**，而是Jvm为了提高锁的获取与释放效率而做的优化(**使用synchronized时**)

**偏向锁**

偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

**轻量级**

轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

**重量级锁**

重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。













