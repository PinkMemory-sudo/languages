# wait/notify

有点类似于单线程中的if，wait/notify中的两个线程，线程A是满足条件的执行，不满足条件的wait线程B会更新条件，在满足A的条件的时候notifyA。调用锁对象的wait/notify。**使用wait/notify需要先获得锁**



## **wait**

当线程没有满足条件时，调用wait方法进行等待,进入阻塞，同时释放锁

wait后进入什么状态？使用notify唤醒或者**interrupt**后停止等待，线程中断导致异常退出，也会释放锁对象

![1638285686184](..\..\..\..\img\1638285686184.png)



**wait(Long)**

超时没被唤醒会自动唤醒



**wait条件发生变化**

会导致什么问题？



生产者消费者模式，当多个消费者发现没有数据时，都进入等待，然后生产者调用notifyAll，都唤醒，一个消费者消费完数据，另一个消费者进入时已经没有数据了，进行消费时就会异常。所以当被唤醒后，还需要判断一下之前的条件



**interrupt到wair方法**

当线程在wait状态时，调用线程的interrupt方法时会出现InterruptedException异常。



## **notify**

notify随机唤醒线程其中的一个，进入就绪态，并不会立即释放锁对象，而是将临界区执行完。



**唤醒过早**

如果notify的时候，没有调用过wait。通知的过早，导致wait一直等待。所以需要添加一个标志位，wait前先判断条件，notify后修改条件。



notifyAll



**注意**

唤醒后



## 生产者消费者模式

解决平衡的问题



涉及到的角色：

生产者：产生数据的线程，生产够数据时notify消费者，还有数据时wait

消费者：取出数据的线程，没数据时wait，有数据时消费数据，消费完后notify生产者





一个资源类提供了两个方法，需要两个方法交替执行

这两个方法需要怎么设计？

线程该怎么调用这两个方法？

交替执行

也就是同一时间这两个方法只能执行一个，所以要这两个方法要用同一个锁对象。但是，使用同一个方法只保证了同一时刻只能有一个方法执行，不能保证交替。我们可以设置一个标记位，true时方法A执行，false时线程B执行。当标志位为true，但是确实线程B



**生产者消费者模式为什么不设计成单线程**



多生产者多消费者，因为一次用多个线程进行生产或者消费，所以可能通过了条件后进入了wait，当被唤醒时，可能被其他线程生产或者消费了，又满足wait条件了，但是它醒来的时候没有再次判断。而单生产者和消费者就不会出现这个情况，因为只有它能消费，被唤醒的时候不用担心被其他线程消费掉。



wait与if-elase









































BlockingQueue实现多生产者-多消费者

















# Join





# ThreadLocal