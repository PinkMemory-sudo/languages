不能用try,catch来获取线程中的异常



## Java Memory Model

JMM并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。



CPU执行速度很快，而内存到CPU读写数据相对来说比较慢，就出现了CPU高速缓存。运行时先将需要的数据从内存复制一份到告诉缓冲中，CPU直接从内存缓冲区中读取数据，运行完之后再将高速缓冲中的数据刷入内存。

单线程运行时没什么问题，但是在多线程的运行中，一个线程复制到告诉缓冲区中后进行了修改，在还没有刷回内存时另一个线程有将内存中的数据刷入告诉缓冲区进行计算，这时已经不一致了，读取的实际是旧的。

解决缓存不一致问题一个做法是加锁，只能有一个线程对变量进行操作，刷回内存后才能被其他线程操作。锁住的是变量所在的内存地址，其他线程读取不了。这种做法导致了效率降低，有可能其他线程只是读取，并未要进行修改。这时就出现了缓存一致性协议：当CPU在曹硕共享变量时，会发出信号使该变量的缓存都失效，重新读取该变量。



Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。



多线程要想正确执行，必须保证原子性可见性和有序性

**原子性**

即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

通过synchronized和Lock来实现，volatile只能保证可见性，保证不了原子性。

**可见性**

可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

**有序性**

即程序执行的顺序按照代码的先后顺序执行。synchronized和Lock可以实现有序性，volatile可以保证一部分有序性。

**指令重排序**

处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。





# Volatile

volatile，易变的；无定性的。



**volatile两个作用**

* 一个线程改变一个volatile变量时会立即写入主内存，然后是其他工作内存中的缓存失效，重新从主内存中读取
* 禁止指令重排序



**进制指令重排序**

* 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

* 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。



**使用volatile的场景**

对变量的写操作不依赖当前值，该变量没有包含在有其他变量的表达式中。即保证对这个变量的操作都是原子性的才能够使用。

* 标记位
* double check时





