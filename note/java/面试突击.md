# 程序汪



自我介绍：

学校，专业，工作经历，项目经历。

自己负责的模块：流程讲清楚，技术亮点说出来(多线程，批处理，自定义注解，经过了几个服务)

* 并行流



* 失败机制
* 重试机制
* 幂等机制，解决幂等性问题就是添加业务ID，判断业务ID是否已经处理过
* 线程池的核心参数









**消息幂等**

主要就是消息重复消费了。一种情况是消费者将消息发送给MQ，MQ没有返回确认时出问题了，消费者任务MQ没有接收到消息就会重新发送，另一种情况是生产者出现问题导致没有给MQ确认，MQ中该条消息就会被其他消费者消费。

如何解决：

消费者再消费前先判断一下ID(MQ内部会给每条消息生成一个id)，再决定是否消费。

监控，报警，补偿





​         

**Spring 中 beanFactory 和 ApplicationContext 的联系和区别**  

两者都可作为容器

BeanFactory：

是Spring里面最低层的接口，提供了最简单的容器的功能，只提供了实例化对象和拿对象的功能；

ApplicationContext：

应用上下文，继承BeanFactory接口，它是Spring的一各更高级的容器，提供了更多的有用的功能

总体区别如下：

1） 使用 ApplicationContext，配置  bean 默认配置是 singleton，无论是否使用，都会被实例化。优点是预先加载，缺点是浪费内存；

2） 使用 BeanFactory 实例化对象时，配置的 bean 等到使用的时候才会被实例化。优点是节约内存，缺点是速度比较慢，多用于移动设备的开发；

3） 没有特殊要求的情况下，应该使用 ApplicationContext 完成，ApplicationContext 可以实现

BeanFactory 所有可实现的功能，还具备其他更多的功能。



## Java



**迭代器**

Collection继承了迭代器接口，所以所有Collection的子类都可以使用迭代器进行遍历。迭代器是的遍历与底层的数据结构隔离。

使用迭代器进行遍历时，不能使用集合自己的remove方法去删除元素，而应该使用iterator的remove方法删除元素。

原因：在生成iterator的时候会生成一个*expectedModCount*，而我们在进行add,remove时会改变ModCount，遍历时检测到两者不相同就会抛异常(*ConcurrentModificationException*)。

使用for循环时可以使用集合自己的remove方法，但是要注意删除后元素前移了，而下次遍历i就++了，就会导致删除的元素之后的一个元素没有遍历到，解决的办法是删除后i--。倒序删除的话就没问题，因为下一个遍历的元素的位置没有改变。



**集合的排序**

collections有多个sort方法，可以传入comparator或者不传入，按找类的comparable排序

也可以使用list的sort(comparator)



**String为什么要使用final**

String不叫常用，被final修饰的类不能被继承



**编码问题gbk、utf-8 不说了最简单的也最容易乱码的问题**



**内存泄露怎么定位**

jmap，jstack 的使用等等



## 容器



**HashMap1.7死循环**

死循环发生在HashMap的扩容函数中，在进行扩容的时候，从新表赋值到旧表采用的是头插法，原因是扩容转移后前后链表顺序倒置.



**HashMap1.8**

在jdk1.8中对HashMap进行了优化，在发生hash碰撞，不再采用头插法方式，而是直接插入链表尾部，因此不会出现环形链表的情况。



**ConcurrentHashMap为什么是线程安全的**

jdk1.7采用Segment + HashEntry + ReentrantLock的方式进行实现的，1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。

JDK1.7

分段锁技术，那我把整张表分成 N 个部分，并使元素尽量均匀的分布到每个部分中，分别给他们加锁，互相之间并不影响，每个部分就是一个 Segment。

HashMap由多个Segment组成，每个Segment可以看成是一个个小HashMao，是HashEntry数组+链表。当对某个Segment上锁时，不会影响其他的Segment。

put时通过key的hash找到segment的下标在通过hash找到它在这个Segment中数组的位置。如果当前Segment被占用，就会使用scanAndLockForPut方法自旋。

remove 方法和 put 方法类似。

size()

先采用乐观的方式，认为在统计 size 的过程中，并没有发生 put， remove 等会改变 Segment 结构的操作。但是，如果发生了，就需要重试。如果重试2次都不成功(执行三次，第一次不能叫做重试)，就只能强制把所有 Segment 都加锁之后，再统计了，以此来得到准确的结果。



JDK1.8

采用synchronized+CAS(此时的 Synchronized 已经升级了，效率得到了很大提升，锁升级可以了解一下)，把锁的粒度进一步降低，而放弃了 Segment 分段，而是给数组中的每一个头节点（为了方便，以后都叫桶）都加锁，锁的粒度降低了。并且，用的是 Synchronized 锁。

底层数据结构与HashMap相同。Key和Value不能为空





**集合和数组之间的转换**





### 泛型

泛型在类，接口，方法中的应用

主要是为了代码复用

**泛型方法**

泛型方法可以灵活的传入参数

```java
public <T> T fun(T t);
```



### 多线程



**使用场景**

* 大数据量的查询

com.google.common.collect.Lists.partition

org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor



**高并发场景接口优化思路**

首先是服务要经受的住，然后是数据库经受的住，最后实在不行的话加入MQ进行削峰，异步处理。

1. 添加负载均衡层，将请求均匀打到系统层。
2. 系统层采用集群化部署多台机器，扛住初步的并发压力。
3. 数据库分库分表 + 读写分离或微服务
4. 缓存集群引入
5. 数据库其实本身不是用来承载高并发请求的
6. 比如说消息中间件技术，也就是MQ集群，是非常好的做写请求异步化处理，实现削峰填谷的效果。



**ConcurrentHashMap**

jdk1.7中是采用Segment + HashEntry + ReentrantLock的方式进行实现的，而1.8中放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现。



## Spring



**事务传播机制**

Service接口方法可能会在内部调用其它的Service接口方法以共同完成一个完整的业务操作，因此就会产生服务接口方法嵌套调用的情况， Spring通过事务传播行为控制当前的事务如何传播到被嵌套调用的目标服务接口方法中。即当前的事务(调用的方法)遇到了另一个事务(方法调用了另一个方法)，另一个事务怎么办。

| 传播行为                  | 描述                                                         |
| ------------------------- | ------------------------------------------------------------ |
| REQUIRED                  | 默认的，如果当前没有事务，就新建一个事务，如果有，就加入当前事务 |
| PROPAGATION_SUPPORTS      | 以当前事务为准，当前没有事务，就以非事务的方式运行           |
| PROPAGATION_MANDATORY     | 以当前事务为准，当前没有事务，就抛出异常                     |
| PROPAGATION_REQUIRES_NEW  | 新建事务，把当前事务挂起                                     |
| PROPAGATION_NOT_SUPPORTED | 不要事务，把当前事务挂起                                     |
| PROPAGATION_NEVER         | 非事务方式运行，当前存在事务时抛出异常                       |
| NESTED                    | 与REQUIRED类似，只不过它是嵌套的事务，嵌套事务出错是不会全部回滚 |



**事务失效的原因**

1. @Transactional加在了方法上，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象来执行事务，而直接通过service调用方法，执行的不是代理对象，所以索引失效了。

总结一句话，**调用了自身而没有经过 Spring 的代理类**

解决方案：事务代码用一个类单独去处理

2. 异常被吃掉了



**Bean**



**SpringMVC工作流程**

1. 用户发送请求至前端控制器DispatcherServlet(HTTP请求的中央调度器)
2. DispatcherServlet收到请求后调用HandlerMapping(请求和处理程序之间的映射)，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet
3. 获取处理器适配器HandlerAdapter(参数封装，数据格式转换，数据验证等操作),执行处理器Handler
4. HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet
5. DispatcherServlet将ModelAndView传给ViewReslover视图解析器
6. ViewReslover解析后返回具体View
7. DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）
8. 响应客户



**Spring线程池**



**拦截器使用**



**AOP**

实现方式：

- 预编译：AspectJ
- 运行期动态代理（JDK动态代理、CGLib动态代理）：SpringAOP

**名词解释**



## 设计模式



**模板模式**

模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。

使用场景

* 固定算法骨架
* 各个子类中有公共的部分
* 需要控制子类情况，扩展留给子类
* 一般Controller类某功能的增删改查

写好固定的处理逻辑



**生产问题**



* 问题
* 原因
* 发现手段
* 解决方案



# MySQL



**乐观锁和悲观锁的对比**

***概念***

乐观锁：不上锁，提交数据的时候在去判断是否产生冲突，宽进严出。

悲观锁：读数据时先上锁，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程

***实现***

乐观锁CAS(Compare and Swap 比较并交换)

表中添加version字段，乐观锁需要用到这个字段。开启事务后添加where version=version，执行操作后如果影响的行数为0，则征兵version发生了改变，就应该失败回滚，重新提交。

悲观锁有MySQL实现

***使用场景***

乐观锁

冲突很少，或冲突后果不会很严重，那么通常应该选择乐观锁，因为它能得到更好并发性，而且更容易实现

悲观锁



**行锁，表锁，读锁，写锁**



**存储过程怎么调试**





# web



**支付宝的接口调用**



**session和cookie的区别**

* cookie保存在浏览器，session保存在服务器，session的安全性要大于cookie，通常使用Cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果有sessionid，服务器将根据该id返回对应Session对象。如果客户端请求中没有sessionid，服务器会创建新的Session对象，并把sessionid在本次响应中返回给客户端。
* session没有大小的限制



接口调用的失败机制，重试机制，幂等机制





# 老黄



## 多线程



**线程的状态和声明周期**

***线程的状态***

| 状态          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 新建状态                                                     |
| RUNNABLE      | 可运行状态，包含READY和RUNNING                               |
| BLOCKED       | 阻塞状态，线程发起阻塞的I/O操作或者申请其他线程占用的资源时。阻塞状态不会占用CPU |
| WAITING       | 等待状态，线程执行了wait或者join状态，执行notify或者加入的线程执行完后进入RUNNABLE |
| TIMED_WAITING | 与WAITING状态类似，但是指定的有时间，超时自动转RUNNABLE      |
| TERMINATED    | 线程运行完之后                                               |

***线程的声明周期***

| 声明周期 | 描述                      |
| -------- | ------------------------- |
| 新建     | 刚被创建                  |
| 就绪     | 调用start()后             |
| 运行     | 获得CPU执行权后           |
| 阻塞     | 阻塞和wait状态            |
| 死亡     | 执行完run方法或者异常退出 |



**接口和抽象类的区别**

**成员的不同**

抽象类被abstract修饰。只是不能被实例化的类，类该有的东西抽象类都有

接口是方法的集合，方法默认被public abstract修饰，变量默认被public static final修饰，jdk1.8后接口中可以定义默认方法和静态方法

**继承与实现**

继承抽象类必须要实现抽象方法或者也定义成抽象类，可以实现多个接口。接口没有构造方法，抽象类可以声明构造方法。



**线程池参数**



**Synchronized静态方法和实例方法的区别**



** ReentrantLock  与Synchronized的区别**

* Synchronized会自动释放锁， ReentrantLock  需要手动释放

* 临界区发生异常时，synchronized会释放锁。 ReentrantLock  不会
* synchronized是公平的锁，ReentrantLock  可以实现非公平锁



**Synchronized锁升级的过程**

偏向锁：不释放

轻量级锁:CAS,自旋一段时间

重量级锁：完全阻塞





**CAS存在什么问题**

Java中专门针对版本号的东西



**AtomicInteger的原理**



**什么时伪共享**



**LongAder**



**ThreadLocal的内部原理**

是一个map，key是什么



**ThreadLocal的变量，父子线程之间是可以共享的吗**

不可以



**怎么停止一个线程**



**什么时候会触发InterruptException**

打断wait时



**什么是IO模型**



## 容器

**ArrayList与LInkedLIst的区别**

数据结构

扩容

适用场景



**HashMap的实现**



## JVM



**JVM内存结构**



**栈帧里面都有什么**



**什么时对象头**



**有哪些垃圾收集算法**



**新生代和老年代的垃圾回收算法**



**强软弱虚的区别**



**字符串常量放在哪里**



**类加载的过程**



**类加载器都有哪些**



## GC

**怎么判断该不该回收**



## ADVANCE



**Java的动态代理**



## MySQL



**ACID**

***原子性*** ：不可分割

***一致性*** ： 事务前后数据的完整性必须保持一致 

***隔离性*** : 各个事务之间不能互相干扰 

***持久性*** :  持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 



**隔离级别**

| 隔离界别        | 描述                                 |
| --------------- | ------------------------------------ |
| read uncommited | 读未提交，会导致脏读，不可重读和幻读 |
| read commited   | 读已提交，会导致不可重读和幻读       |
| (默认)          | 可重复度，会导致幻读                 |
|                 | 串行读                               |

- 脏读：指一个事务读取到了另外一个事务未提交的数据。
- 不可重复读：指一个事务读取到了另外一个事务提交的update的数据 ，导致前后两次读取的不一致
- 幻读：一个事务读取到了另一个事务insert的



**存储引擎**

* MyISAM：较高的插入查询性能，支持全文索引，但不支持事务
* InnoBD：支持事务。支持行级锁(默认的存储引擎)
* Memory：所有数据存在内存中极高的插入和查询性能



**存储引擎的数据结构**



**为什么用B+树**



InNoDB,**聚簇索引**，一个表有且只有一个聚簇索引，叶子节点，双链表，节点与页



**MySQL有哪些索引类型**

* 普通索引：
* 主键索引：
* 唯一索引：
* 组合索引：多列组成一个索引
* 全文索引：只有MyISAM支持



**什么是聚簇索引**

聚簇索引存数据，其他索引存ID



**InNoDB中主键索引和非主键索引有什么区别**



**什么是覆盖索引**



**索引下推**



**什么是回表查询**



**索引失效**



**limit做分页有什么问题**

后面的性能会比较差



**MySQL调优的思路和步骤**

* 机器内存，buffer pool
* 调用链，索引没交或者没有命中索引，或者说有回表操作



页，区，冷堆



## Redis



**你用过redis中的哪些数据类型**

String



**缓存穿透**



**缓存击穿**



**缓存雪崩**



**redis为什么单线程还这么快**



## WEB



**session的实现方式(分布式session)**



### nginx

**正向代理和反向代理的区别**

* 正向代理代理的是客户端，反向代理代理的是服务端



**nginx的负载均衡策略**

* 轮询
* 设置权重
* 一致性hash，ipHash与url_hash





## NET



**HTTP的状态码**

* 500
* 401
* 302



**为什么要进行三次握手和四次挥手，详细点**



## 设计模式



模板模式



怎么实现单例设计模式，饿汉式，懒汉式



## 分布式



**什么是微服务**



**分布是的优点**

哪个用到的多哪个就多部署一点



**分布式的缺点**

* 难以管理
* 依赖网络



**分布是的组件**

 



微服务有什么优缺点



**JWT**







## 算法



**你知道的排序方法有哪些，时间复杂度**



## ？

随机IO



# 哔哩哔哩



## Java基础

LinkedList是一个双端队列



## Java并发



## JVM 



## MySQL

**ACID靠什么保证**

原子性：通过日志

隔离性：由MVCC保证

持久性：由内存和日志保证，宕机时通过日志恢复

一致性：一致性是目的，由其他三大特性保证



**MySQL的日志**



**B树和B+树的区别**



**MVCC**



**引擎**

行锁表锁

事务



**分库分表的策略和方法**



**什么是垂直分表，什么是水平分表**



**分布式ID是怎么生成的**

雪花算法？



## Redis

事务



**布隆过滤器**



持久化

快照和日志



## Spring



## MyBatis







## MQ



**你们的项目为什么要使用MQ**



**怎么保证消息不丢失**



**怎么避免消息重复消费，实现一下**







## 网络



## ES



## 算法



## 分布式


抽象类和接口的区别





