# Basic



**==与equals的区别**

==比较的是地址，判断是不是同一个对象

equals在没有重写时等价于==，用来比较地址，重写后用来比较对象的内容。常用的String重写了equals方法。



**为什么重写 equals 时必须重写 hashCode 方法**

默认情况下，hashCode是对象在堆中的一个特殊值，而equals比较的则是在堆中的地址，所以无论如何，每个对象的hashcode和equals都不会相同。

对象的hashcode主要用来计算出该对象在hash表中的索引，然后equals来比较两个对象是否相同这样就减少了比较的次数；而如果equals相同，hashcode不同，就会导致相同的元素出现在了hash表的不同位置，

所以必须保证：

**equals相同时，hashCode也一定要相同**。所以重写了equals方法，则生成hashcode的条件也要发生改变。



**为什么Java只有值传递**

值传递就是实参中保存的值(不管是值还是一个地址)，复制给形参，形参对它的值进行修改，实参的值并不会被改变。所以Java中可以改变实参引用的对象的内容，但改变不了它的引用。



**final关键字的作用**

被 final 修饰的变量不可以被改变，  如果修饰引用,那么引用不可变,引用指向的内容可变

被 final 修饰的方法,可以继承但不能重写，JVM 会尝试将其内联,以提高运行效率

被 final 修饰的类不可以被继承(断子绝孙类)



**Java 序列化中如果有些字段不想进行序列化，怎么办**

使用 transient 关键字修饰



**深拷⻉ vs 浅拷⻉**

浅拷⻉:对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷⻉，此为浅拷⻉。

深拷⻉:对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷⻉



**能否重写父类的构造方法**

不能，构造方法不会被继承



**一个无参的构造方法有什么用**

子类默认会调用父类的无参构造方法



**成员变量和局部变量的区别**

* 成员变量声明在类中，可以被修饰符修饰，局部变量声明在方法中，导致两者存储的位置和声明周期不同
* 成员变量有默认值



**静态方法和成员方法的不同**

* 静态方法属于类，通过类名调用，非静态方法属于某个实例，通过实例名调用

* 非静态方法可以调用静态方法



**什么是多态，Java是如何实现的**

就是指同一个引用类型，使用不同的实例而执行不同的操作

继承，重写，父类引用指向子类的实现



**Java中有没有指针**

有，JVM使用，我们不能用



**四个访问修饰符合访问级别**  

类中的，同包的，子类的，公共的：private，protected，友好的，public



**static都有哪些用法**  

static可以作用于变量,方法，代码块，内部类。

被static修饰，会在类被加载的时候就加载，被所有的对象所共享，在内存中只有一个副本。不依赖于对象，可以直接调用。



**static代码块和普通代码块的区别**

static代码块只在类加载的时候执行一次，普通代码块会在每次创建对象时执行一次



**Object 中有哪些公共方法**

hashCode(),返回对象的hash值，主要为了方便计算散列表的索引

equale()与==是一样的，用来比较地址。子类一般需要重写该方法，来比较内容。

toString()返回对象的文本表达形式

clone()对象的浅拷贝(只有实现了 Cloneable 接口才可以调用该方法)

getClass()获得对象的class

notify()

notifyAll()

wait()

finalize()



**&和&&的区别**

两者都可以进行逻辑与运算，&是按位与。&&具用断路功能，即第一个表达式为false时不在进行逻辑与直接返回



## 变量



**Java 的基础类型和字节大小**

boolean 	    8位

byte			    8位

char			    16位

short	  		16位

int				   32位

long				64位

float				32位

double			64位



**a=a+b与a+=b的区别**

a+=b会将计算结果隐式的转为持有的结果



**3*0.1==0.3的结果**

false



**char能不能存一个汉字**

可以，Java使用的是unicode编码，一个char占两个字节



**switch 能否作用在 byte、long、string 上** 

switch 可作用在 char、byte、short、int(小于等于int的数字)及他们的包装类上和String



**在调用子类构造方法之前会先调用父类没有参数的构造方法, 其目的是**

创建父类对象



**怎么使用BigDecimal进行浮点型数据运算**

1. 获得BigDecimal对象new BigDecimal(String)获得静态方法BigDecimal.valueOf(Double)
2. 调用加减乘除运算，add,subtract,multiply,divide
3. 返回String或者double



**Match常用方法**

pow，round，abs，random



## 面向对象



**面向对象和面向过程的区别:**

面向过程执行效率更高



**代码块与构造函数的执行优先级**



**哪些方法不能被重写**

被final修饰的方法，static修饰的方法，或private修饰的方法，跨包的话因为不可见所以也不能重写



**new 一个对象的过程和 clone 一个对象的过程**

* new是java中的关键字。他通过调用类的对应构造方法来创建对象。它会在JVM中重新生成一块空的内存空间，再调用构造函数对对象进行初始化，最后返回对象的地址。
* clone方式需要实现Cloneable接口来重写clone的方法，如果不实现就重写会报java.lang.CloneNotSupportedException的异常。先分配内存，再调用clone方法对原对象进行复制，最后返回新对象地址。
  



为什么要使用内部类**

* 要解决一个复杂的问题，并希望创建一个类，用来辅助自己的程序方案。同时不愿意把它公开
* 从某种意义上可以实现多继承



**为什么匿名内部类和局部内部类只能访问局部final变量**

内部类和外部类是同一级别的，不会因为外部类执行完就回收内部类。

当外部类执行完销毁时，可能内部类还没执行完，需要用到外部类的变量。解决办法就是内部类会复制一份外部类中的局部变量来作为内部类的类变量，但是为了与外部类保持一致，就需要使用到final来控制。



**内部类和静态内部类的区别**



**abstract class 和 interface 有什么区别**

由abstract修饰的方法叫抽象方法;由abstract修饰的类叫抽象类。抽象类就是一个还不完善的类

在软件工程中,接口泛指供别人调用的方法或者函数， 在Java语言中,接口是对行为的抽象,是**方法声明的集合**(主要)

* 类用来定义属性和行为，而接口则主要声明类要实现的行为。
* 接口没有构造方法，抽象类中可以定义构造函数(声明通用的构造函数)
* Java8前，接口中都是抽象方法(java8新增default和非抽象方法, jdk9以后可以有private，9之前定义private会便宜报错的 )，抽象类中可以有抽象方法，也可以有实现的方法
* 接口中只能由static 和 final 变量 ，不能有其他成员变量
*  从设计层⾯来说，抽象是对类的抽象，是⼀种模板设计，⽽接⼝是对⾏为的抽象，是⼀种⾏ 为的规范 
*  Jdk 9 在接⼝中引⼊了私有⽅法和私有静态⽅法 



**Java8中的接口都可以有什么**

* Java8之前，接口中的方法被public abstract隐式修饰，Java8后允许default和static
* 接口中声明的变量隐式的被 public static final 修饰



**Java 的多态表现在哪里**

父类的引用变量可以保存子类的不同实例



**哪些类是不能被继承的**

final修饰的类，如String，Double等



**方法重载的规则**

同名不同参，其他的异常，返回值等无关



## 字符串



**判断一个String中只包含数字**

```
s.matches("[0-9]{1,}")
```



**怎么指定字符串的编码形式**

new String(s.getBytes(),"编码")



**String、StringBuilder、StringBuffer 区别**  

String是不可变字符，都会生成一个新对象(会转成StringBuilder，然后append，再toString)，所以在进行大量字符串拼接是会产生许多对象

StringBuilder只产生一个对象，然后一直append来拼接

StringBuffer与StringBuilder相同，但是StringBuffer是线程安全的



**String str="hello world"和String str=new String("hello world")的区别**

使用""创建的字符串存储在堆中的字符串常量池中，相同的内容只会存储一份。new String()，通过new创建出来的字符串存储是在堆内存中，不会去检查是否存在。



**String a = "hello2"; String b = "hello" + 2; System.out.println((a == b));会输出什么**

true， "hello" + 2会在编译时被jvm优化成"hello2"，所以a和b是同一个对象



**String a = "hello2"; 　 String b = "hello";    String c = b + 2;    System.out.println((a == c));的输出结果**

false 因为c是间接相加的，jvm不会对引用变量进行优化



## 日期



**SimpleDateFormat为什么是线程不安全的**

其中存放日期数据的变量都是线程不安全的。



**怎么计算两个日期的间隔**

两个日期间的比较可以使用isAfter等，而计算间隔可以使用ChronoUnit.DAYS/hour/minutes等的between方法。





## 异常



**throw 和 throws 的区别**

throw用来抛出一个异常对象，作用在方法内部

throws表示出现异常的一种可能性，作用在方法名后

​        

 **Java 中怎么创建一个不可变对象** 

​        

 **Java 中 ++ 操作符是线程安全的吗**

​         

**final、finalize 和 finally 的不同之处**  

finalize 是 Object 类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法， 可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等，jdk9以后这个方法就过时了



## 反射



获取 Class对象 的三种方式       

* 通过实例获得：对象.getClass()方法
* 通过类名获得：类名.class
* 通过Class获得：Class.forName("xxx")



**获得所有字段**

getFields()获得所有公共的字段(包括父类)

getDeclaredFields()获得所有声明的字段(不包括父类)



**什么是反射**  

反射就是在运行时获得Class运行的信息，修改检查信息。



**反射的作用**

可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；



反射中，Class.forName()和 ClassLoader.loadClass()的区别？



## IO



**Java有几种类型的流**

按照流的流向分，可以分为输入流和输出流;
按照操作单元划分，可以划分为字节流和字符流;

主要都是从InputStream/Reader，OutputStream/Writer派生来的



**既然有了字节流,为什么还要有字符流**

字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的。

字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符



**使用IO的最佳实践**

* 使用有缓冲的IO类
* 使用NIO或者NIO2
* 在finally中关闭流或者使用try-with-resource



**BIO,NIO,AIO的区别**

BIO： 同步阻塞 I/O 模式，就是我们平常使用的IO，使用简单，并发低。

NIO： 同步非阻塞I/O模式，通过channel传输，实现了多路复用

AIP： NIO2，异步非阻塞的 IO 模型，基于事件和回调机制

同步与异步，阻塞与非阻塞的区别：IO包括IO的请求以及实际IO，阻塞和非阻塞发生在IO的请求，同步和异步发生在IO的操作。



**Files常用的方法**

| 方法                | 描述             |
| ------------------- | ---------------- |
| Files.exists()      | 是否存在         |
| Files.createFile()  | 创建文件         |
| Files.creatDirectoy | 创建文件夹       |
| Files.delete()      | 删除文件或文件夹 |
| Files.copy()        | 复制文件         |
| Files.move()        | 移动文件         |
| Files.size()        | 查看文件个数     |
| Files.read()        | 读               |
| FIles.write()       | 写               |



**字节流和字符流的区别**

2. 字节流与字符流怎么选
3. 缓冲区的作用
4. 缓冲流与缓冲区的区别
5. 字节流和字符流的区别
6. 什么是Java序列化，如何实现Java序列化
7. 什么是节点流和处理流
8. 各个read方法的含义
9. 字节数组流
10. read()与read(byte[] b)区别



**Log4j对程序有影响吗**

将日志记录到本地或者数据库需要消耗IO，频繁操作，会对系统性能产生影响



# 容器



**集合排序**



## List



**Arraylist 与 LinkedList 区别?**

ArrayList的***数据结构***是数组，LinkedList的数组结构是链表，所以两者的主要区别就是数组和链表的区别。

ArrayList适合通过下标进行***随机访问***，LinkedList适合频繁插入删除的情况。

ArrayList需要连续的空间，不够时需要扩容，重新分配空间，LinkedList不用。

内存***空间***占用：ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空 间，而 LinkedList 的空间花费则体现在它的每一个元素都需要存放直接后继和直接前驱以及数据



**List,Set,Map三者的区别**

* List : 存储的元素是有序的、可重复的。 
* Set : 存储的元素是无序的、不可重复的。
* Map: 使用键值对(kye-value)存储，可以不能重复，value可以重复



**List和Set的区别**

List是有序的，元素可以重复，Set相反。List有下标，所以可以使用for循环。



**ArrayList 与 Vector 区别**

ArrayList和Vector都是List的实现类主要区别在与Vector是线程安全的，两者的扩容机制也有所区别



 **ArrayList 的扩容机制**

初始容量，扩容时的比较条件。



**怎么创建一个只读的容器**

调用Collections.unmodifiableCollection(collections s)创建



**多线程场景下如何使用ArrayList**

ArrayList是非线程安全的，需要使用Collections的syschronizedList转为安全的list



## Set



**set怎么保证不重复的**

会先计算对象的 hashcode 值来判断对象加入的位置，同 时也会与其他加入的对象的 hashcode 值作比􏰀，如果没有相符的 hashcode ， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让加入操作成功。



**HashSet 的底层实现是什么**  

HashMap，用的都是HashMap的方法



**为什么重写 equals 时必须重写 hashCode 方法**

默认情况下，hashCode是对象在堆中的一个特殊值，而equals比较的则是在堆中的地址，所以无论如何，每个对象的hashcode和equals都不会相同。对象的hashcode主要用来计算出该对象在hash表中的索引，然后equals来比较两个对象是否相同这样就减少了比较的次数；在set中，会先根据hashcode计算出索引比较是否相同，有的还在调用equals比较对象是否相同来保证元素不重复，如果equals相同但是hashcode不同，可能计算出来的索引不同，就不能保证元素不重复。

所以必须保证：

equals相同时，hashCode也一定要相同。所以重写了equals方法，则生成hashcode的条件也要发生改变。



**HashSet 和 TreeSet 有什么区别**

HashSet通过HashMap实现，TreeSet通过TreeSet实现

存入HashSet需要重新HashCode和equals

存入TreeSet需要实现Comparable



**什么是迭代器**

用来遍历集合，消除了数据结构不同的差异



**Iterator 和 ListIterator 的区别是什么？**

* Iterator 可用来遍历 Set 和 List 集合，但是 ListIterator 只能用来遍历 List
* Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向。
* ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。



## Map



**Hashtable 和 Hashmap 的区别**


* 初始容量，扩容机制不同
* 安全性：HashMap 是非线程安全的， HashTable 是线程安全的,因为 HashTable 内 部的方法基本都经过 synchronized 修饰
* 效率：HashTable虽然线程安全，但是效率比较低，基本不用
* null值：hashmap的key允许有一个null，hashtable不允许
* 厨师容量和扩容机制：HashMap默认厨师容量16，每次扩大到原来的2倍，hashtable默认容量11，每次扩大到原来的2n+1
* 底层数据结构：1.8后，Hashmao加入了红黑树，hashtable没有



**HashMap实现原理**

Jdk1.8后引入了红黑树，当一个链表的长度达到阈值8时，如果当前数组的长度小于64，就会先进行扩容，否则就把链表转成红黑树



**容量为什么是2的幂次方**

当大是2的幂次方时，求余操作求可以通过(lengh-1)$hash来操作，这样每次根据Hash计算位置时效率就高得多了



**HashMap怎么保证容量是2的倍数的**



**为什么是0.75**



**为什么是8**

泊松分布



**HashMap 多线程操作导致死循环问题**

不推荐多线程使用HashMap



**ConcurrentHashMap 和 Hashtable 的区别**

两者实现线程安全的方式不同

***底层数据结构***：jdk1.8之前ConcurrentHashMap使用的是分段数组+链表来实现，jdk1.8开始，数据结构与jdk1.8的HashMap结构相同，采用CAS和Synchronized来实现线程安全。Hashtable的数据结构与jdk1.7的hashMap相似

***实现线程安全的方式***: 在 JDK1.7 的时候， ConcurrentHashMap (分段锁) 对整个桶数组进行了分割分段( Segment )，每一把锁只锁容器其中一部分数据，多线程访问 容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经 摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发 控制使用 synchronized 和 CAS 来操作。虽然在 JDK1.8 中还能看到Segment 的数据结构，只是为了兼容旧版本。hashtable使用 synchronized 来保证线程安全，效率非常低下



**ConcurrentHashMap线程安全的具体实现方式/底层具体实现**

Jdk1.7

是分成多个segment，每个segment配一把锁

Jdk1.8

synchronized 只锁定当前链表或红黑二叉树的首节点，锁的粒度更小，这样只要 hash 不冲突，就不会产生并 发，效率又提升 N 倍。



**TreeMap、HashMap、LindedHashMap 的区别**   

LinkedHashMap是HashMap的子类，多了一个链表用来保证顺序。







**HashSet、LinkedHashSet 和 TreeSet 三者的异同**

HashSet 的底层是 HashMap ，线程不安全的，可以存储 null 值;

LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历;

TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排 序





**什么是迭代器(Iterator)**

 



**Iterator 和 ListIterator 的区别是什么？**

* Iterator是遍历Collection的通用的方法，ListIterator 只能用来遍历LIst

* Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向
*  ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等



**Iterator   遍历时修改？**



**Comparable 和 Comparator接口的区别**  

这两个接口主要用来对集合进行排序。

实现Comparable接口的类，可以直接用来排序。通过Collections.sort()来排序。

而没有实现Comparable接口的类要想排序，需要定义一个比较器。通过list.sort,传入一个Comparator来排序。

Comparable实现compareTo来定义与跟一个对象的比较方法

Comparator实现compare方法定义两个对象的比较

第一个参数-第二个参数为升序

Java中  String、Byte、Char、Date 等大量的类都实现了Compareable接口。



# JVM



**栈帧里面都有什么**



**什么是对象头**



**字符串常量放在哪里**



**什么是JVM，JVM都包括什么**



**内存划分**  

  

**如何判断一个对象应该被回收**  



**创建对象的过程**

1. 类加载检查：检查是否已经被加载过(到方法区中找)，没有的话要执行类加载操作
2. 分配内存：开辟堆内存空间
3. 初始化零值：就是设置默认值
4. 设置对象头：比如这个对象的Hash,GC分代的年龄，是哪个类的实例
5. 执行init方法：父类变量的初始化、语句块，构造器，子类的变量初始化，代码块，构造器

* 父类>子类，静态>非静态，代码块>构造方法



**32位JVM和64位JVM最大的内存**

32位：2^32(4GB)

64位：2^64，很大，1000G都可以



**获得JVM位数**

sun.arch.data.model或者os.arch



**获得Java程序的内存使用信息**

Runtime类的freememory()等方法



**运行时常量池，方法区和元空间**



**字符串常量池到底存在于内存空间的哪里**  

* jdk 6.0 字符串常量池在方法区，方法区的具体体现可以看做是堆中的永久区。

* jdk 7.0 java 虚拟机规范中不再声明方法区，字符串常量池存放在堆空间中

* jdk 8.0 java 虚拟机规范中又声明了元空间，字符串常量池存放在元空间中。



## 垃圾回收



**都有哪些垃圾回收算法，都有哪些弊端**

* 标记清除： ⾸先标记出所有不需要回收的对象，在标记完成后统⼀回收掉所 有没有被标记的对象。 造成了内存碎片
* 复制算法： 以将内存分为大小相同的两块，每次使⽤其中 的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。浪费了一半内存。
* 标记整理：标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存。移动增加了开销。
* 分代收集：般将 java 堆分为新⽣代和⽼年代，每个代使用不同的算法。



**老年代为什么使用标记整理和标记清除，新生代为什么要使用复制算法**

触发Full GC的频率要低，里面保存的对象被GC的可能性小，大对象也保存在老年代中，老年代还需要自己兜底内存，标记清楚和标记整理不会浪费内存，所以使用这两个方法。

新生代中的对象大部分都会被GC，所以使用复制算法效率高，而且空间也并不是1:1等分而是8:1:1,只浪费了10%内存。



**一个对象是如何从新生代到老年代的**



**如何回收Class**

* 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 
* 加载该类的 ClassLoader 已经被回收。 
* 该类对应的 java.lang.Class 对象没有在任何地⽅被引⽤，⽆法在任何地⽅通过反射访问该类 的⽅法。 



**都有哪些垃圾收集器**

Serial 收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿， 只使用一个线程去回收。
ParNew 收集器，ParNew 收集器其实就是 Serial 收集器的多线程版本。
Parallel 收集器，Parallel Scavenge 收集器类似 ParNew 收集器，Parallel 收集器更关注系统的吞吐量。
Parallel Old 收集器，Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记－整理”算法
CMS 收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

G1 收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征



**什么是类加载器，有哪些作用**

用来将一个class文件加载进内存， 并对数据进行检验、转换解析和初始化，最终创建一个Class对象。



**类加载的过程**

* 加载
* 链接
* 初始化



**类加载器的种类**

* 启动类加载器(Bootstrap ClassLoader): 最顶级的加载器， 负责加载jvm的核心类库，比如`java.lang.*`等，从系统属性中的`sun.boot.class.path`所指定的目录中加载类库 
* 扩展类加载器(Extension ClassLoader)：从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre/lib/ext子目录（扩展目录）下加载类库，如果把用户的jar文件放在这个目录下，也会自动由扩展类加载器加载。
* 应用程序类加载器(Application ClassLoader)：从环境变量classpath或者系统属性java.class.path所指定的目录中加载类。
* 自定义加载器(User ClassLoader)



**什么是双亲委派模型**

根据双亲委派模式，在加载类文件的时候，子类加载器首先将加载请求委托给它的父加载器，父加载器会检测自己是否已经加载过类，如果已经加载则加载过程结束，如果没有加载的话则请求继续向上传递直Bootstrap ClassLoader。如果请求向上委托过程中，如果始终没有检测到该类已经加载，则Bootstrap ClassLoader开始尝试从其对应路劲中加载该类文件，如果失败则由子类加载器继续尝试加载，直至发起加载请求的子加载器为止。



**为什么要使用双亲委派模型**

 免类的重复加载，这样就可以保证任何的类加载器最终得到的都是同样一个Object对象。 



**双亲委派模型缺陷**



**怎么打破双亲委派模型**

自定义类加载器，重写loadClass方法自己指定使用哪个类加载器来加载。



**SPI为什么要打破双亲委派机制**



**自定义类加载器的用途**

* 依赖冲突，各自加载各自的依赖
* 加密



**堆内存中，对象的分配策略**

* 一般都会先进入eden
* 大对象直接进入老年代(eden放不下)
* 长期存活的对象进入老年代



**简单的介绍一下强引用,软引用,弱引用,虚引用**



**怎么回收无用类**

方法区主要回收类信息，



**内存泄露**

理论上因为有GC，不会导致内存泄露，然而实际开发中，会存在一些无用但是可达的对象导致不能被GC，



**如果对象的引用被置为null，GC是否会立即释放对象占用的空间**



**串行收集器和吞吐量收集器的区别是什么**

吞吐量收集器采用并行的新生代垃圾收集器，用于中大规模应用

串行收集器对于大多数小型(100M内存左右)足够了







**介绍下 Java 内存区域(运行时数据区)**



**创建对象的过程**







**堆**



JDK1.8前，堆内存模型主要分为：

1. 新生代内存(Young Generation) 
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

JDK 8 版本之后方法区(HotSpot 的永久代)被彻底移除了(JDK1.7 就已经开始了)，取而代 之是元空间，元空间使用的是直接内存



**方法区**

它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

```
 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现 它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方 法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中 的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并 没有永久代这一说法。
```



Java8取消了方法区替换为元空间



元空间常用参数

```
 -XX:MetaspaceSize=N //设置 Metaspace 的初始(和最小大小) 
 -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```



**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace)** 





**GC**







**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢**



**串行收集器和吞吐量收集器的区别**



常量池

**字符串常量池到底存在于内存空间的哪里**  



 **Java 中的编译期常量是什么？**

编译时就能够知道变量的值并且值不会再改变的变量，会直接替换成值。这种就是编译期常量(即使那种final修饰的并且直接赋值的)



# 多线程



**为什么要使用多线程**



**线程的状态和声明周期**

***线程的状态***

| 状态          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| NEW           | 新建状态                                                     |
| RUNNABLE      | 可运行状态，包含READY和RUNNING                               |
| BLOCKED       | 阻塞状态，线程发起阻塞的I/O操作或者申请其他线程占用的资源时。阻塞状态不会占用CPU |
| WAITING       | 等待状态，线程执行了wait或者join状态，执行notify或者加入的线程执行完后进入RUNNABLE |
| TIMED_WAITING | 与WAITING状态类似，但是指定的有时间，超时自动转RUNNABLE      |
| TERMINATED    | 线程运行完之后                                               |

***线程的声明周期***

| 声明周期 | 描述                      |
| -------- | ------------------------- |
| 新建     | 刚被创建                  |
| 就绪     | 调用start()后             |
| 运行     | 获得CPU执行权后           |
| 阻塞     | 阻塞和wait状态            |
| 死亡     | 执行完run方法或者异常退出 |



 **实现 Runnable 接⼝和 Callable 接⼝的区别** 

* Runnable 接⼝不会返回结果或抛出检查异常，但是 Callable 接⼝可以。
* Runnable执行run方法，Callable执行call方法 



**执⾏ execute()⽅法和 submit()⽅法的区别是什么呢？**

* execute() ⽅法⽤于提交不需要返回值的任务
* submit() ⽅法⽤于提交需要返回值的任务， 线程池会返回⼀个 Future 类型的对象 。



**FutureTask 对象** 





**Synchronized和Lock区别**

sunchronized发生异常会释放锁 



？

* 锁分离
* 线程的dump文件
* 线程池，最大线程数过大的后果



## 线程池



**线程池原理分析**





**线程池的参数**

| 参数                     | 说明                                                         |
| ------------------------ | ------------------------------------------------------------ |
| corePoolSize             | 线程池要保持的线程的数量                                     |
| maximumPoolSize          | 线程池中最多可以保存的线程数                                 |
| keepAliveTime            | 大于核心线程数时，如果执行时间内没有分配到任务就会清掉       |
| TimeUnit                 | keepAliveTime的单位                                          |
| BlockingQueue            | 在线程数达到最大时，就会存放在队列中(runnable通过execute提交的) |
| ThreadFactory            | 线程池用它来创建线程                                         |
| RejectedExecutionHandler | 线程数已经达到最大，并且队列也满了，对新提交的任务怎么拒绝   |

结合线程数先变大再减少的场景去记忆



**线程池的拒绝策略**

| 拒绝策略             | 说明                                                         |
| -------------------- | ------------------------------------------------------------ |
| AbortPolicy          | 抛弃任务,直接抛出 RejectedExecutionException 异常阻止系统正常运行 |
| DiscardPolicy        | 直接抛弃任务，不抛出异常                                     |
| DiscardOledestPolicy | 丢弃掉最先入队的，重新尝试添加到队列中                       |
| CallerRunsPolicy     | 调用者自己去执行任务                                         |



**最大线程数设置过大会有什么后果**

* 线程时需要内存空间的，创建的线程过多就会占用过大的内存空间
* 线程上下文切换需要消耗时间，线程数太多而进行频繁切换也会浪费时间
*  netty的建议是设置为2倍的cpu核心数。 



**进程和线程的区别**

* 进程是资源分配(内存，文件等)的最小单位，线程是CPU调度的最小单位。

* 一个进程可以有多个线程，共享进程的资源。所以线程执行时一般都要进行同步和互斥。
* 线程切换消耗的资源要比进程小得多，线程也被成为轻量级进程



**并发和并行的区别**

并发是一段时间内执行多个任务

并行是同一时间内执行多个任务



**为什么要使用多线程**

* 线程共享进程的资源，切换的开销要比进程小
* 一个线程在不使用CPU的情况下可以让别的线程先用，提高效率，减少执行的时间，提高并发量



**使用wait和notify写一个生产者消费者代码**



**写一个线程安全的单例模式**



**进行对线程开发时，你有哪些最佳实践**

* 给线程命名，有助于调试
* 最小化同步的范围
* 使用更高层次的开发工具BlockQueue等而不是wait和notify
* 优先使用并发集合而不是同步
*  尽量把阻塞型的IO密集任务，转成CPU密集任务，这样你只需要少量线程也可以获得很高的吞吐量。这就是为何select、poll 、epoll、nginx可以用很少的线程可以获得极大吞吐量的原因。 





**线程同步的方法**

* Synchronized
* Lock
* volatile



## **Java内存模型**



 **ThreadLocal 了解么** 

 每⼀个线程都有自己的专属本地变量。

 ThrealLocal 类中可以通过 Thread.currentThread() 获取到当前线程对象后，直接通过 getMap(Thread t) 可以访问到该线程的 ThreadLocalMap 对象。 



 **ThreadLocal 原理** 

 最终的变量是放在了当前线程的 ThreadLocalMap 中 

当前对象调用set方法，实际是将值存在了ThreadLocalMap中，key是当前的Thread对象。



 **ThreadLocal 内存泄露问题了**

ThreadLocal.ThreadLocalMap.Entry中的key是弱引用的，也即是当某个ThreadLocal对象不存在强引用时，就会被GC回收，但是value是基于强引用的，所以当key被回收，但是value还存在其他强引用时，就会出现内存的泄露情况，在最新的ThreadLocal中已经做出了修改，即在调用set、get、remove方法时，会清除key为null的Entry，但是如果不调用这些方法，仍然还是会出现内存泄漏 ：），所以要养成用完ThreadLocal对象之后及时remove的习惯。





## Synchronized



**对于 synchronized 关键字的了解** 

synchronized关键字用来解决线程间的同步问题，synchronized修饰的方法和代码块在同一时间只能被一个线程执行。

synchronized关键字可以用来修饰实例方法，静态方法和代码块。修饰实例方法时，使用的锁对象时this，修饰静态方法时，使用的时当前类的Class对象，修饰代码块时自己指定锁对象。

 尽量不要使⽤ synchronized(String a) 因为 JVM 中，字符串常量池具有缓存功能， 两个String的值一致时指向的地址是一致的，其实两个线程锁的是同一个对象。



**Synchronized实现的底层原理**

 monitorenter 和 monitorexit 指令 

 ACC_SYNCHRONIZED 标 





**Synchronized锁升级的过程**

偏向锁：不释放

轻量级锁:CAS,自旋一段时间

重量级锁：完全阻塞

 因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映 射到操作系统的原⽣线程之上的。如果要挂起或者唤醒⼀个线程，都需要操作系统帮忙完成， 





## volatile



**创建volatile数组**

只保证了引用的可见性



**volatile能使一个非原子操作变成一个原子操作吗**



volatile提供了什么保证

* 可见性
* 一部分有序性



容器的Concurent

notify，线程通信

锁

wait，join，yeid，notify

Volatile、CAS

volatile 变量和 atomic 变量有什么不同

线程间通信，wait 和 notify 的理解和使用?

定时线程的使用?

什么是竞争条件

如何停止一个线程

线程池的优点

volatile 的理解

实现多线程有几种方式

ReentrantLock

守护线程是什么？它和非守护线程的区别

线程阻塞有哪些原因

synchronized 和 Lock 的区别

ThreadLocal 是什么？有什么作用

什么是线程局部变量

FutureTask

什么是自旋

怎么唤醒一个阻塞的线程

使用 volatile 关键字的场景

线程池的工作原理，几个重要参数

线程池的类型

线程池的阻塞队列有哪些

线程池的拒绝策略都有哪些



**并发与并行**

并行就是一个时间点做多件事

并发就是一个时间段内来回切换做多件事



**为什么要使用多线程**

线程的切换成本远小于进程，多核 CPU 时代意味着多个线程可以同时运行，这减少 了线程上下文切换的开销。

为了提高CPU的利用率，减少程序运行时间。



**什么是上下文切换**

多线程通常是线程数大于CPU数，一个CPU来回切换来执行多个线程。当一个线程执行完CPU时间段切换到另一个线程前，会先将自己的当前状态先保存起来，等再次切换回这个任务时在把状态加载出来接着执行。

上下文切换通常是计算密集型的，也就是他要占用相当比例的处理器时间。Linux 相比与其他操作系统(包括其他类 Unix 系统)有很多的优点，其中有一项就是，其上下文 切换和模式切换的时间消耗非常少。



**多线程可能带来什么问题**

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如:内存泄漏、上下文切换、死锁 。



**线程的基本状态**

线程有流中状态

| 状态     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| new      | 新建 线程对象创建后进入新建状态                              |
| runnable | 就绪 线程的start()被调用后进入就绪态，等待CPU调度            |
| running  | 运行 获得CPU执行权后                                         |
| blocked  | 阻塞 因某种原因放弃了CPU的执行权进入阻塞态(等待阻塞，同步阻塞，其他阻塞)，随后会再次进入就绪态，等待获得CPU执行权 |
| dead     | 死亡 线程执行完后者引异常退出了run方法                       |

等待阻塞：

同步阻塞

其他阻塞



**产生死锁的四个条件**

互斥条件：改资源任一时刻只能有一个线程占用

请求与保持条件：一个进程因请求资源而阻塞时，不释放自己一获得的资源

不剥夺条件：线程已经获得的资源不可剥夺，只有自己使用完毕后才释放资源

循环等待条件：若干进程间形成一种头围相连的循环等待条件



**如何避免死锁**

破坏行程死锁的四个条件中的任意一条就可以：请求资源时一次请求全部的资源，没有得到时把自己已有的资源释放掉。

互斥条件：无法破坏，因为我们使用锁的目的就是让他互斥

请求与保持条件：一次申请全部资源，这样就不会因某个资源被其他线程占用而阻塞

不可剥夺条件：如果没有申请到其他线程占用的资源时，把自己占用的那部分释放掉

循环等待条件：



**sleep方法和wait方法的异同**

* 都会是线程进入阻塞状态，sleep不会释放锁，wait会释放锁。
* wait使用前提是先获得锁，通过锁调用wait方法

* sleep到时间后继续执行wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或 者 notifyAll() 方法。 或者可以使用 wait(long timeout) 超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒。



**run方法和start方法的区别**

调用 start() 方法，会启动一个线程并使线程进入了就 绪状态，当分配到时间片后就可以开始运行了。

直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它



**synchronized**

synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。解决多个线程之间访问资源的同步性。



**为什么Java 早期版本中， synchronized 属于 重量级锁，效率低下**

因为监视器锁(monitor)是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映 射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而 操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比􏰀 ⻓的时间，时间成本相对􏰀高



**JDK1.6后synchronized的优化**

JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。



**怎么使用 synchronized 关键字**

**修饰实例方法**：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁

**修饰静态方法**：也就是给当前类加锁，会作用于类的所有对象实例。进入同步代码前要获得 当 前 class 的锁。

如果一个线程 A 调用一个实例对象的 非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法， 是允许的，不会发生互斥现象，因为访问静态 **synchronized** 方法占用的锁是当前类的锁，而访 问非静态 **synchronized** 方法占用的锁是当前实例对象锁。

**修饰代码块**：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进入同步代码 库前要获得给定对象的锁。 synchronized(􏰄.class) 表示进入同步代码前要获得 当前 **class** 的锁

总结：给Class加锁和给对象加锁



**双重校验实现单例对象**





 **构造方法可以使用 synchronized 关键字修饰么**

不能。

构造方法本身就属于线程安全的。



**synchronized 关键字的底层原理**



## JUC



**原子类**



**AQS**

**对于 AQS 原理的理解**

AQS 核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线
程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞
等待以及被唤醒时锁分配的机制，这个机制 AQS 是⽤ CLH 队列锁实现的，即将暂时获取不到锁
的线程加⼊到队列中。



**AQS 对资源的共享⽅式**

独占，共享guid



**⽤过 CountDownLatch 么？什么场景下⽤的**  



# Java8新特性



Stream API，充分利用现代多核 CPU  

**Time API**  

接口  



 **JDK 1.7 中的新特性**

* try-with-resource ，不需要手动关闭流
* switch，允许String
* 类型推断，<>推断
* catch可以捕获多个异常



**JDK1.8的新特性**

* lambda表达式
* StreamAPI
* Date与TimeAPI
* 接口中可以有静态方法和默认方法

































make PREFIX=~/2022/redis/ install





## 为什么不建议使用Arrays.asList、ArrayList的subList





设计模式

66道































数据结构与算法

**双向链表和双向循环链表**



# other



**JDBC的使用步骤**

加载驱动

获得数据库连接

执行SQL语句

获得结果集

关闭连接



**数据库连接池技术**



没有临时变量的情况下怎么交换两个值



# 算法



折半查找



冒泡排序



# 设计模式

55



**什么是设计模式，为什么要使用设计模式**

代码涉及经验的总结，为了能重用代码，提高代码可读性



**单例模式**

双重校验实现单例模式



**什么是里氏替换原则**



**什么情况下会违反迪米特法则**



**什么时候用适配器模式**



**适配器模式和装饰器模式的区别**



**适配器模式和代理模式的区别**



**什么是模板方法模式**



访问者模式



组合模式



**继承和组合有什么不同**





**聚合和关联有什么区别**



**开闭原则**

对扩展开发，对修改关闭，增加新功能时只需要实现接口。



**抽象工厂模式和原型模式的区别**



**享元模式**



# 网络



**TCP/IP的五层协议**

物理层，数据链路层，网络层，传输层，应用层



## **http**

设计 HTTP 最初的目的是为 了提供一种发布和接收 HTML ⻚面的方法



**各种协议与HTTP协议之间的关系**



**HTTP的长连接和短连接**

实际是TCP的长连接和短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次 连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web⻚中包含有其 他的Web资源(如JavaScript文件、图像文件、CSS文件等)，每遇到这样一个Web资源，浏览 器就会重新建立一个HTTP会话。而从HTTP/1.1起，默认使用⻓连接，用以保持连接特性。使用⻓连接的HTTP协议，会在响应头 加入这行代码:`Connection:keep-alive`



ftp



SMPT



**TCP与UDP的区别**

两者都是传输层的协议，TCP提供面向连接的，可靠的数据传输 服务。UDP提供无连接的，尽最大努力的数据传输服 务(不保证数据传输的可靠性)。



**TCP的三次握手和四次挥手**

三次握手是为了**双方能确认对方可以进行收发**。

第一次握手，service，确认了client可以发送数据，自己可以接收数据

第二次握手，client确认了自己的收发没问题

第三次握手，service确认自己的发送和对方的接收没问题

客户端现发送SYN信号，服务端使用SYN-ACK应答，客户端在恢复ACK建立联系。

断开一个连接则需要"四次挥手"

**确保双方都没有数据要传输了**，即双方都要发送关闭连接的请求，然后等对方同意，就需要四次挥手了。

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一 方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

比如A想要关闭连接，B收到后确认，但是它还有东西要传输，A就会处于半连接状态，等B也发送关闭请求时，A发送确认然后关闭连接。



**在浏览器中输入url地址 到 显示主⻚的过程**

1. DNS域名解析获得IP
2. 根据HTTP协议生成请求报文
3. 建立TCP连接进行报文传输
4. 路由选择



**套接字编程实现回显**



