# Basic



**==与equals的区别**

==比较的是地址，判断是不是同一个对象

equals在没有重写时等价于==，用来比较地址，重写后用来比较对象的内容。常用的String重写了equals方法。



**为什么重写 equals 时必须重写 hashCode 方法**

默认情况下，hashCode是对象在堆中的一个特殊值，而equals比较的则是在堆中的地址，所以无论如何，每个对象的hashcode和equals都不会相同。

对象的hashcode主要用来计算出该对象在hash表中的索引，然后equals来比较两个对象是否相同这样就减少了比较的次数；而如果equals相同，hashcode不同，就会导致相同的元素出现在了hash表的不同位置，

所以必须保证：

**equals相同时，hashCode也一定要相同**。所以重写了equals方法，则生成hashcode的条件也要发生改变。



**为什么Java只有值传递**

值传递就是实参中保存的值(不管是值还是一个地址)，复制给形参，形参对它的值进行修改，实参的值并不会被改变。所以Java中可以改变实参引用的对象的内容，但改变不了它的引用。



**final关键字的作用**

被 final 修饰的变量不可以被改变，  如果修饰引用,那么引用不可变,引用指向的内容可变

被 final 修饰的方法,可以继承但不能重写，JVM 会尝试将其内联,以提高运行效率

被 final 修饰的类不可以被继承(断子绝孙类)



**Java 序列化中如果有些字段不想进行序列化，怎么办**

使用 transient 关键字修饰



**深拷⻉ vs 浅拷⻉**

浅拷⻉:对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷⻉，此为浅拷⻉。

深拷⻉:对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷⻉



**什么是字节码，采用字节码的好处**



**Java采用什么编码方案，有何特点**



**能否重写父类的构造方法**



**String为什么不可变**



**一个无参的构造方法有什么用**



**成员变量和局部变量的区别**

* 成员变量声明在类中，可以被修饰符修饰，局部变量声明在方法中，导致两者存储的位置和声明周期不同
* 成员变量有默认值



**静态方法和成员方法的不同**



**调用总类构造方法时会调用父类的构造方法，为什么**



**什么是多态，Java是如何实现的**



**Java中有没有指针**



**math中常用的方法**





## 变量



**a=a+b与a+=b的区别**

a+=b会将计算结果隐式的转为持有的结果



**3*0.1==0.3的结果**

false



char能不能转int，String，double



**char能不能存一个汉字**

可以，Java使用的是unicode编码，一个char占两个字节



**浮点型数据应该怎么计算**



**如何颠倒一个数组的顺序**



**成员变量与局部变量的区别有哪些**

1. 成员变量是属于类,可以被访问修饰符修饰
2. 成员变量有默认值



**静态方法和实例方法有何不同**

1. 在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方 式。
2. 静态方法只能访问静态成员



**在调用子类构造方法之前会先调用父类没有参数的构造方法, 其目的是**



**怎么使用BigDecimal进行浮点型数据运算**

1. 获得BigDecimal对象new BigDecimal(String)获得静态方法BigDecimal.valueOf(Double)
2. 调用加减乘除运算，add,subtract,multiply,divide
3. 返回String或者double



**Match常用方法**

pow，round，abs，random



## 面向对象



**面向对象和面向过程的区别:**





## 字符串



判断一个String中只包含数字

```
matches("[0-9]{1,}")
```



怎么指定字符串的编码形式

new String(s.getBytes(),"编码")



## 日期

55道



**SimpleDateFormat为什么是线程不安全的**

其中存放日期数据的变量都是线程不安全的。



**怎么计算两个日期的间隔**

两个日期间的比较可以使用isAfter等，而计算间隔可以使用ChronoUnit.DAYS/hour/minutes等的between方法。





## 异常



**Java 的基础类型和字节大小**

boolean 	    8位

byte			    8位

char			    16位

short	  		16位

int				   32位

long				64位

float				32位

double			64位



**为什么匿名内部类和局部内部类只能访问局部final变量**

内部类和外部类是同一级别的，不会因为外部类执行完就回收内部类。

当外部类执行完销毁时，可能内部类还没执行完，需要用到外部类的变量。解决办法就是内部类会复制一份外部类中的局部变量来作为内部类的类变量，但是为了与外部类保持一致，就需要使用到final来控制。



**四个访问修饰符合访问级别**  

类中的，同包的，子类的，公共的：private，protected，友好的，public

​         

**成员变量和局部变量的区别有哪些**

* 成员变量属于对象，存在堆中，局部变量存在栈中，所以生命周期不相同
* 成员变量有默认值，局部变量没有默认值



**static都有哪些用法**  

static可以作用于变量,方法，代码块，内部类。

被static修饰，会在类被加载的时候就加载，被所有的对象所共享，在内存中只有一个副本。不依赖于对象，可以直接调用。



**static代码块和普通代码块的区别**

static代码块只在类加载的时候执行一次，普通代码块会在每次创建对象时执行一次



**abstract class 和 interface 有什么区别**

由abstract修饰的方法叫抽象方法;由abstract修饰的类叫抽象类。抽象类就是一个还不完善的类

在软件工程中,接口泛指供别人调用的方法或者函数， 在Java语言中,接口是对行为的抽象,是**方法声明的集合**(主要)

* 类用来定义属性和行为，而接口则主要声明类要实现的行为。
* 接口没有构造方法，抽象类中可以定义构造函数(声明通用的构造函数)
* Java8前，接口中都是抽象方法(java8新增default和非抽象方法, jdk9以后可以有private，9之前定义private会便宜报错的 )，抽象类中可以有抽象方法，也可以有实现的方法
*  接口中只能由static 和 final 变量 ，不能有其他成员变量




**Java8中的接口都可以有什么**

* Java8之前，接口中的方法被public abstract隐式修饰，Java8后允许default和static
* 接口中声明的变量隐式的被 public static final 修饰



**内部类有什么作用**



​         

**Object 中有哪些公共方法**

hashCode(),返回对象的hash值，主要为了方便计算散列表的索引

equale()与==是一样的，用来比较地址。子类一般需要重写该方法，来比较内容。

toString()返回对象的文本表达形式

clone()对象的浅拷贝(只有实现了 Cloneable 接口才可以调用该方法)

getClass()获得对象的class

notify()

notifyAll()

wait()

finalize()



**&和&&的区别**

两者都可以进行逻辑与运算，&是按位与。&&具用断路功能，即第一个表达式为false时不在进行逻辑与直接返回



   

说几个常见的编译时异常 

**throw 和 throws 的区别**

throw用来抛出一个异常对象，作用在方法内部

throws表示出现异常的一种可能性，作用在方法名后



 运行时异常与一般异常有何异同  

  

**方法重载的规则**

同名不同参，其他的异常，返回值等无关



方法重写的规则

重载和重写的区别   







内存泄漏和内存溢出

什么是反射  



反射的作用

反射中，Class.forName()和 ClassLoader.loadClass()的区别？



**String、StringBuilder、StringBuffer 区别**  

String是不可变字符，都会生成一个新对象(会转成StringBuilder，然后append，再toString)，所以在进行大量字符串拼接是会产生许多对象

StringBuilder只产生一个对象，然后一直append来拼接

StringBuffer与StringBuilder相同，但是StringBuffer是线程安全的



**String str="hello world"和String str=new String("hello world")的区别**

使用""创建的字符串存储在堆中的字符串常量池中，相同的内容只会存储一份。new String()，通过new创建出来的字符串存储是在堆内存中，不会去检查是否存在。



**String a = "hello2"; String b = "hello" + 2; System.out.println((a == b));会输出什么**

true， "hello" + 2会在编译时被jvm优化成"hello2"，所以a和b是同一个对象



**String a = "hello2"; 　 String b = "hello";    String c = b + 2;    System.out.println((a == c));的输出结果**

false 因为c是间接相加的，jvm不会对引用变量进行优化



**强引用和软引用和弱引用以及虚引用** 

弱引用：失去最后一个强引用后就会被GC回收

软引用：内存不足时才会被回收

​       

 数组在内存中如何分配



​        

 Java 中怎么创建一个不可变对象 



​        

 Java 中 ++ 操作符是线程安全的吗



​         

new 一个对象的过程和 clone 一个对象的过程

  

​         

final、finalize 和 finally 的不同之处  

垃圾回收器在回收某个对象的时候，首先会调用该对象的finalize()方法，jdk9以后这个方法就过时了





Java 的多态表现在哪里



哪些类是不能被继承的







**代码块与构造函数的执行优先级**





**哪些方法不能被重写**

​         

静态类型有什么特点



深拷贝和浅拷贝的区别是什么 



什么是值传递和引用传递

​    

**switch 能否作用在 byte、long、string 上** 

switch 可作用在 char、byte、short、int(小于等于int的数字)及他们的包装类上和String



Iterator   遍历时修改？



## 反射



获取 Class对象 的三种方式       

* 通过实例获得：对象.getClass()方法
* 通过类名获得：类名.class
* 通过Class获得：Class.forName("xxx")



**通过反射实例化对象和通过new实例化对象那个效率高**





## IO



**Java有几种类型的流**

按照流的流向分，可以分为输入流和输出流;
按照操作单元划分，可以划分为字节流和字符流;

主要都是从InputStream/Reader，OutputStream/Writer派生来的



**既然有了字节流,为什么还要有字符流**

字符流是由Java虚拟机将字节转化为2个字节的Unicode字符为单位的字符而成的。

字节流提供了处理任何类型的IO操作的功能，但它不能直接处理Unicode字符



**使用IO的最佳实践**

* 使用有缓冲的IO类
* 使用NIO或者NIO2
* 在finally中关闭流或者使用try-with-resource



**BIO,NIO,AIO的区别**

52页

BIO： 同步阻塞 I/O 模式，就是我们平常使用的IO，使用简单，并发低。

NIO： 同步非阻塞I/O模式，通过channel传输，实现了多路复用

AIP： NIO2，异步非阻塞的 IO 模型，基于事件和回调机制



**Files常用的方法**

| 方法                | 描述             |
| ------------------- | ---------------- |
| Files.exists()      | 是否存在         |
| Files.createFile()  | 创建文件         |
| Files.creatDirectoy | 创建文件夹       |
| Files.delete()      | 删除文件或文件夹 |
| Files.copy()        | 复制文件         |
| Files.move()        | 移动文件         |
| Files.size()        | 查看文件个数     |
| Files.read()        | 读               |
| FIles.write()       | 写               |



**字节流和字符流的区别**



2. 字节流与字符流怎么选
3. 缓冲区的作用
4. 缓冲流与缓冲区的区别
5. 字节流和字符流的区别
6. 什么是Java序列化，如何实现Java序列化
7. 什么是节点流和处理流
8. 各个read方法的含义
9. 字节数组流
10. read()与read(byte[] b)区别



**Log4j对程序有影响吗**

将日志记录到本地或者数据库需要消耗IO，频繁操作，会对系统性能产生影响



# 容器





## List



**Arraylist 与 LinkedList 区别?**

ArrayList的数据结构是数组，LinkedList的数组结构是链表，所以两者的主要区别就是数组和链表的区别。

ArrayList适合通过下标进行随机访问，LinkedList适合频繁插入删除的情况。

ArrayList需要连续的空间，不够时需要扩容，重新分配空间，LinkedList不用。

内存空间占用：ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空 间，而 LinkedList 的空间花费则体现在它的每一个元素都需要存放直接后继和直接前驱以及数据



**List,Set,Map三者的区别**

* List : 存储的元素是有序的、可重复的。 
* Set : 存储的元素是无序的、不可重复的。
* Map: 使用键值对(kye-value)存储，可以不能重复，value可以重复



**List和Set的区别**

List是有序的，元素可以重复，Set相反。List有下标，所以可以使用for循环。



**ArrayList 与 Vector 区别**

ArrayList和Vector都是List的实现类主要区别在与Vector是线程安全的，两者的扩容机制也有所区别



 **ArrayList 的扩容机制**



**怎么创建一个只读的容器**

调用Collections.unmodifiableCollection(collections s)创建



**对线程场景下如何使用ArrayList**

ArrayList是非线程安全的，需要使用Collections的syschronizedList转为安全的list



## Set



**set怎么保证不重复的**

set进行add时，实际调用的是HashMap的put方法，会先判断元素的hashcode，如果不相同，则认为是两个不同的对象，直接插入，如果相同，则进一步调用equals来比较。



**HashSet 的底层实现是什么**  

HashMap，用的都是HashMap的方法



**为什么重写 equals 时必须重写 hashCode 方法**

默认情况下，hashCode是对象在堆中的一个特殊值，而equals比较的则是在堆中的地址，所以无论如何，每个对象的hashcode和equals都不会相同。对象的hashcode主要用来计算出该对象在hash表中的索引，然后equals来比较两个对象是否相同这样就减少了比较的次数；在set中，会先根据hashcode计算出索引比较是否相同，有的还在调用equals比较对象是否相同来保证元素不重复，如果equals相同但是hashcode不同，可能计算出来的索引不同，就不能保证元素不重复。

所以必须保证：

equals相同时，hashCode也一定要相同。所以重写了equals方法，则生成hashcode的条件也要发生改变。





**HashSet 和 TreeSet 有什么区别**

HashSet通过HashMap实现，TreeSet通过TreeSet实现

存入HashSet需要重新HashCode和equals

存入TreeSet需要实现Comparable



## Map



**Hashtable 和 Hashmap 的区别**


* 初始容量，扩容机制不同
* 安全性：HashMap 是非线程安全的， HashTable 是线程安全的,因为 HashTable 内 部的方法基本都经过 synchronized 修饰
* 效率：HashTable虽然线程安全，但是效率比较低，基本不用
* null值：hashmap的key允许有一个null，hashtable不允许
* 厨师容量和扩容机制：HashMap默认厨师容量16，每次扩大到原来的2倍，hashtable默认容量11，每次扩大到原来的2n+1
* 底层数据结构：1.8后，Hashmao加入了红黑树，hashtable没有



**HashMap实现原理**

Jdk1.8后引入了红黑树，当一个链表的长度达到阈值8时，如果当前数组的长度小于64，就会先进行扩容，否则就把链表转成红黑树



**容量为什么是2的幂次方**

当大是2的幂次方时，求余操作求可以通过(lengh-1)$hash来操作，这样每次根据Hash计算位置时效率就高得多了



**HashMap 多线程操作导致死循环问题**

不推荐多线程使用HashMap



**ConcurrentHashMap 和 Hashtable 的区别**

两者实现线程安全的方式不同

***底层数据结构***：jdk1.8之前ConcurrentHashMap使用的是分段数组+链表来实现，jdk1.8开始，数据结构与jdk1.8的HashMap结构相同。Hashtable的数据结构与jdk1.7的hashMap相似

***实现线程安全的方式***: 在 JDK1.7 的时候， ConcurrentHashMap (分段锁) 对整个桶数组进行了分割分段( Segment )，每一把锁只锁容器其中一部分数据，多线程访问 容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经 摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发 控制使用 synchronized 和 CAS 来操作。虽然在 JDK1.8 中还能看到Segment 的数据结构，只是为了兼容旧版本。hashtable使用 synchronized 来保证线程安全，效率非常低下



**ConcurrentHashMap线程安全的具体实现方式/底层具体实现**

Jdk1.7

是分成多个segment，每个segment配一把锁

Jdk1.8

synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并 发，效率又提升 N 倍。



**TreeMap、HashMap、LindedHashMap 的区别**   



Set


**HashSet如何检查重复**

会先计算对象的 hashcode 值来判断对象加入的位置，同 时也会与其他加入的对象的 hashcode 值作比􏰀，如果没有相符的 hashcode ， HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查hashcode 相等的对象是否真的相同。如果两者相同， HashSet 就不会让加入操作成功



**HashSet、LinkedHashSet 和 TreeSet 三者的异同**

HashSet 的底层是 HashMap ，线程不安全的，可以存储 null 值;

LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历;

TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排 序





**什么是迭代器(Iterator)**

 



**Iterator 和 ListIterator 的区别是什么？**

* Iterator是遍历Collection的通用的方法，ListIterator 只能用来遍历LIst

* Iterator 对集合只能是前向遍历，ListIterator 既可以前向也可以后向
*  ListIterator 实现了 Iterator 接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等





​         实现集合的排序 

​         ArrayList 源码分析  

​         HashMap 源码分析  

​         ConcurrentHashMap 源码分析   

**Comparable 和 Comparator接口的区别**  

这两个接口主要用来对集合进行排序。

实现Comparable接口的类，可以直接用来排序。通过Collections.sort()来排序。

而没有实现Comparable接口的类要想排序，需要定义一个比较器。通过list.sort,传入一个Comparator来排序。

Comparable实现compareTo来定义与跟一个对象的比较方法

Comparator实现compare方法定义两个对象的比较

第一个参数-第二个参数为升序









Java中  String、Byte、Char、Date 等大量的类都实现了Compareable接口。



# JVM

​         内存划分  

​         什么是 Java 虚拟机？为什么 Java 被称作是无关平台的编程语言  

​         如何判断一个对象应该被回收  



**创建对象的过程**



**32位JVM和64位JVM最大的内存**

32位：2^32(4GB)

64位：2^64，很大，1000G都可以



**获得JVM位数**

sun.arch.data.model或者os.arch



**获得Java程序的内存使用信息**

Runtime类的freememory()等方法



## 内存模型



Jvm在运行程序时会将内存分成若干不同的区域，主要分成两部分：线程共有的和线程私有的。



### 线程共有的



#### 堆

JVM中堆是最大的一块内存空间，所有线程共享的一块区域，在虚拟机启动的时候创建。

用来存放new出来的数据。几乎所有的对象都保存在堆中，随着JIT编译期的发展与逃逸分析技术逐渐 成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐 变得不那么“绝对”了。

从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被 返回或者未被外面使用(也就是未逃逸出去)，那么对象可以直接在栈上分配内存。

Java 堆是垃圾收集器管理的主要区域，因此也被称作**GC** 堆

Jdk1.8前，堆被分为新生代，老年代，永久代

JDK 8 版本之后方法区(HotSpot 的永久代)被彻底移除了(JDK1.7 就已经开始了)，取而代 之是元空间，元空间使用的是直接内存





#### 方法区

方法区用来存储已被虚拟机加载的类信息，常量，静态变量等。方法区也称为永久代。

jdk1.8取消了方法区，用元空间代替。

**运行时常量池**

运行时常量池是方法区的一部分



#### 直接内存

非运行时数据区的一部分，其他的都是运行时数据区。

直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部 分内存也被频繁地使用





### 线程私有的



#### 虚拟机栈

用来描述方法执行的内存模型。每一次函数调用都会有一个 对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。

存放着一个个栈帧，每个栈帧中保存着局部变量表，操作数栈，动态链接，方法出口等信息。

局部变量表存放着编译期可知的各种数据类和对象的引用

Java虚拟机栈可能会出现两种错误：StackOverFlowError 和 OutOfMemoryError

***StackOverFlowError*** : 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈 的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。

***OutOfMemoryError*** : 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多 内存的话。就会抛出 OutOfMemoryError 错误。



#### 本地方法栈

与虚拟机栈相似，但是本地方法栈执行的是native方法。在hotspot虚拟机中本地方法栈和Java虚拟机栈合而为一。



#### 程序计数器

程序计数器记录着当前线程所执行的字节码的行号指示器，线程切换后根据程序计数器能恢复到正确的执行位置。





































# 垃圾回收



**内存泄露**

理论上因为有GC，不会导致内存泄露，然而实际开发中，会存在一些无用但是可达的对象导致不能被GC，



对象的引用置为null是否会被回收



**串行收集器和吞吐量收集器的区别是什么**

吞吐量收集器采用并行的新生代垃圾收集器，用于中大规模应用

串行收集器对于大多数小型(100M内存左右)足够了





**什么是JVM，JVM都包括什么**



**介绍下 Java 内存区域(运行时数据区)**



**创建对象的过程**







**堆**



JDK1.8前，堆内存模型主要分为：

1. 新生代内存(Young Generation) 
2. 老生代(Old Generation)
3. 永生代(Permanent Generation)

JDK 8 版本之后方法区(HotSpot 的永久代)被彻底移除了(JDK1.7 就已经开始了)，取而代 之是元空间，元空间使用的是直接内存



**方法区**

它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

```
 《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现 它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方 法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中 的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并 没有永久代这一说法。
```



Java8取消了方法区替换为元空间



元空间常用参数

```
 -XX:MetaspaceSize=N //设置 Metaspace 的初始(和最小大小) 
 -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小
```



**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace)** 





**GC**







**为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢**





**如果对象的引用被置为null，GC是否会立即释放对象占用的空间**



**串行收集器和吞吐量收集器的区别**



常量池

**字符串常量池到底存在于内存空间的哪里**  



 **Java 中的编译期常量是什么？**

编译时就能够知道变量的值并且值不会再改变的变量，会直接替换成值。这种就是编译期常量(即使那种final修饰的并且直接赋值的)



# JUC

？

* 锁分离
* 线程的dump文件



**使用wait和notify写一个生产者消费者代码**



**写一个线程安全的单例模式**



**进行对线程开发时，你有哪些最佳实践**

* 给线程命名，有助于调试
* 最小化同步的范围
* 使用更高层次的开发工具BlockQueue等而不是wait和notify
* 优先使用并发集合而不是同步





**线程同步的方法**

* Synchronized
* Lock
* volatile



**进程和线程的区别**

进程是资源分配的最小单位，线程是CPU调度的最小单位。一个进程可以有多个线程，共享进程的资源。所以线程执行时一般都要进行同步和互斥。



## volatile



**创建volatile数组**

只保证了引用的可见性



**volatile能使一个非原子操作变成一个原子操作吗**



volatile提供了什么保证

* 可见性
* 一部分有序性



容器的Concurent

notify，线程通信

锁

wait，join，yeid，notify

Volatile、CAS

volatile 变量和 atomic 变量有什么不同

线程间通信，wait 和 notify 的理解和使用?

定时线程的使用?

什么是竞争条件

如何停止一个线程

线程池的优点

volatile 的理解

实现多线程有几种方式

ReentrantLock

守护线程是什么？它和非守护线程的区别

线程阻塞有哪些原因

synchronized 和 Lock 的区别

ThreadLocal 是什么？有什么作用

什么是线程局部变量

FutureTask

什么是自旋

怎么唤醒一个阻塞的线程

使用 volatile 关键字的场景

线程池的工作原理，几个重要参数

线程池的类型

线程池的阻塞队列有哪些

线程池的拒绝策略都有哪些



**并发与并行**

并行就是一个时间点做多件事

并发就是一个时间段内来回切换做多件事



**为什么要使用多线程**

线程的切换成本远小于进程，多核 CPU 时代意味着多个线程可以同时运行，这减少 了线程上下文切换的开销。

为了提高CPU的利用率，减少程序运行时间。



**什么是上下文切换**

多线程通常是线程数大于CPU数，一个CPU来回切换来执行多个线程。当一个线程执行完CPU时间段切换到另一个线程前，会先将自己的当前状态先保存起来，等再次切换回这个任务时在把状态加载出来接着执行。

上下文切换通常是计算密集型的，也就是他要占用相当比例的处理器时间。Linux 相比与其他操作系统(包括其他类 Unix 系统)有很多的优点，其中有一项就是，其上下文 切换和模式切换的时间消耗非常少。



**多线程可能带来什么问题**

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如:内存泄漏、上下文切换、死锁 。



**线程的基本状态**

线程有流中状态

| 状态     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| new      | 新建 线程对象创建后进入新建状态                              |
| runnable | 就绪 线程的start()被调用后进入就绪态，等待CPU调度            |
| running  | 运行 获得CPU执行权后                                         |
| blocked  | 阻塞 因某种原因放弃了CPU的执行权进入阻塞态(等待阻塞，同步阻塞，其他阻塞)，随后会再次进入就绪态，等待获得CPU执行权 |
| dead     | 死亡 线程执行完后者引异常退出了run方法                       |

等待阻塞：

同步阻塞

其他阻塞



**什么是死锁**



**产生死锁的四个条件**

互斥条件：改资源任一时刻只能有一个线程占用

请求与保持条件：一个进程因请求资源而阻塞时，不释放自己一获得的资源

不剥夺条件：线程已经获得的资源不可剥夺，只有自己使用完毕后才释放资源

循环等待条件：若干进程间形成一种头围相连的循环等待条件



**如何避免死锁**

破坏行程死锁的四个条件中的任意一条就可以

互斥条件：无法破坏，因为我们使用锁的目的就是让他互斥

请求与保持条件：一次申请全部资源，这样就不会因某个资源被其他线程占用而阻塞

不可剥夺条件：如果没有申请到其他线程占用的资源时，把自己占用的那部分释放掉

循环等待条件：



**sleep方法和wait方法的异同**

都会是线程进入阻塞状态，sleep不会释放锁，wait会释放锁

wait常用于线程间的交互/通信，sleep通常被用于暂停执行

wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或 者 notifyAll() 方法。 或者可以使用 wait(long timeout) 超时后线程会自动苏醒。sleep() 方法执行完成后，线程会自动苏醒。



**run方法和start方法的区别**

调用 start() 方法，会启动一个线程并使线程进入了就 绪状态，当分配到时间片后就可以开始运行了。

直接执行 run() 方法，会把 run() 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它



**synchronized**

synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。解决多个线程之间访问资源的同步性。



**为什么Java 早期版本中， synchronized 属于 重量级锁，效率低下**

因为监视器锁(monitor)是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映 射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而 操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比􏰀 ⻓的时间，时间成本相对􏰀高



**JDK1.6后synchronized的优化**

JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。



**怎么使用 synchronized 关键字**

**修饰实例方法**：作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁

**修饰静态方法**：也就是给当前类加锁，会作用于类的所有对象实例。进入同步代码前要获得 当 前 class 的锁。

如果一个线程 A 调用一个实例对象的 非静态 synchronized 方法，而线程 B 需要调用这个实例对象所属类的静态 synchronized 方法， 是允许的，不会发生互斥现象，因为访问静态 **synchronized** 方法占用的锁是当前类的锁，而访 问非静态 **synchronized** 方法占用的锁是当前实例对象锁。

**修饰代码块**：指定加锁对象，对给定对象/类加锁。 synchronized(this|object) 表示进入同步代码 库前要获得给定对象的锁。 synchronized(􏰄.class) 表示进入同步代码前要获得 当前 **class** 的锁

总结：给Class加锁和给对象加锁



**双重校验实现单例对象**





 **构造方法可以使用 synchronized 关键字修饰么**

不能。

构造方法本身就属于线程安全的。



**synchronized 关键字的底层原理**











# Java8新特性



Stream API，充分利用现代多核 CPU  

**Time API**  

接口  



 JDK 1.7 中的新特性

​         **try-with-resource**  

​         Fork-Join  

​         **Switch**   

​         菱形操作符**(<>)用于类型推断**  

JDK1.8的新特性

































make PREFIX=~/2022/redis/ install





## 为什么不建议使用Arrays.asList、ArrayList的subList





设计模式

66道































数据结构与算法

**双向链表和双向循环链表**



# other



**JDBC的使用步骤**

加载驱动

获得数据库连接

执行SQL语句

获得结果集

关闭连接



**数据库连接池技术**



没有临时变量的情况下怎么交换两个值



# 设计模式

55



**什么是设计模式，为什么要使用设计模式**

代码涉及经验的总结，为了能重用代码，提高代码可读性



**单例模式**



**什么是里氏替换原则**



**什么情况下会违反迪米特法则**



**什么时候用适配器模式**



**适配器模式和装饰器模式的区别**



**适配器模式和代理模式的区别**



**什么是模板方法模式**



访问者模式



组合模式



**继承和组合有什么不同**





**聚合和关联有什么区别**



**开闭原则**

对扩展开发，对修改关闭，增加新功能时只需要实现接口。



**抽象工厂模式和原型模式的区别**



**享元模式**



# 网络



http



ftp



SMPT



tcp与udp的区别





**套接字编程实现回显**